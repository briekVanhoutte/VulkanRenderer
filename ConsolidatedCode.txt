Consolidated Code from 'C:\Users\briek\Documents\GitHub\VulkanRenderer'



----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Game.h -----

#pragma once

#include <chrono>
#include <iostream>
#include <thread>
#include <vector>
#include <iomanip>

#include <Engine/Core/WindowManager.h>
#include <Engine/Input/InputManager.h>
#include <Engine/Graphics/RendererManager.h>
#include <Engine/Physics/PhysxBase.h>
#include <Engine/Scene/SceneModelManager.h>
#include <Engine/Scene/GameSceneManager.h>

class Game {
public:
    Game();
    ~Game();

    void init();
    void run();

private:
    void initScene();

    bool m_CapFps = false;
    const int m_FPSCap = 60;
    const std::chrono::nanoseconds m_FrameDuration = std::chrono::nanoseconds(1'000'000'000 / m_FPSCap);

    WindowManager& m_WindowManager;
    RendererManager* m_Renderer;
    Camera* m_Camera;

    PhysxBase& m_Physics;
    SceneModelManager& m_SceneManager;
    GameSceneManager& m_GameScene;

    std::vector<RenderItem> m_RenderItems;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Game.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Core\Singleton.h -----

#pragma once

template <typename T>
class Singleton
{
public:
	static T& GetInstance()
	{
		static T instance{};
		return instance;
	}

	virtual ~Singleton() = default;
	Singleton(const Singleton& other) = delete;
	Singleton(Singleton&& other) = delete;
	Singleton& operator=(const Singleton& other) = delete;
	Singleton& operator=(Singleton&& other) = delete;

protected:
	Singleton() = default;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Core\Singleton.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Core\WindowManager.h -----

#pragma once
#include <GLFW/glfw3.h>
#include <Engine/Platform/PlatformWindow.h>

class WindowManager {
public:
    static WindowManager& GetInstance();

    void initWindow();

    PlatformWindow* getPlatformWindow() const;

    void handleKeyEvent(int key, int scancode, int action, int mods);
    void handleCursorPos(double xpos, double ypos);
    void handleMouseButton(int button, int action, int mods);

#ifdef _WIN32
    static void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);
    static void cursorPosCallback(GLFWwindow* window, double xpos, double ypos);
    static void mouseButtonCallback(GLFWwindow* window, int button, int action, int mods);
#endif

private:
    WindowManager();
    ~WindowManager();

    WindowManager(const WindowManager&) = delete;
    WindowManager& operator=(const WindowManager&) = delete;
    WindowManager(WindowManager&&) = delete;
    WindowManager& operator=(WindowManager&&) = delete;

    PlatformWindow* m_platformWindow = nullptr;
};


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Core\WindowManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\CommandBuffer.h -----

#pragma once
#include "vulkan\vulkan_core.h"

class CommandBuffer {
public:
	CommandBuffer() {};

	void setVkCommandBuffer( VkCommandBuffer buffer);
	VkCommandBuffer m_VkCommandBuffer;;
	void reset()const;
	void beginRecording()const;
	void endRecording()const;

	void submit(VkSubmitInfo& info) const;
private:
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\CommandBuffer.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\CommandPool.h -----

#pragma once

#include <vulkan/vulkan_core.h>
#include <Engine/Graphics/CommandBuffer.h>
#include <Engine/Graphics/Vertex.h>
#include <Engine/Graphics/QueueFamilyIndices.h>

class CommandPool
{
public:
	CommandPool() {};
	VkCommandPool m_CommandPool{ VK_NULL_HANDLE };
	
	void initialize( const QueueFamilyIndices& queue);
	void destroy();

	CommandBuffer createCommandBuffer() const;
private:
	VkDevice m_VkDevice;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\CommandPool.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\DataBuffer.h -----

#pragma once
#include <stdexcept>
#include <cstring>
#include <vulkan/vulkan_core.h>

class DataBuffer
{
public:
    DataBuffer(
        VkPhysicalDevice physicalDevice,
        VkDevice device,
        VkBufferUsageFlags usage,
        VkMemoryPropertyFlags properties,
        VkDeviceSize size
    );

    ~DataBuffer() = default;

    // Back-compat names, now zero-cost wrappers over persistent mapping
    void upload(VkDeviceSize size, void* data);
    void uploadRaw(VkDeviceSize size, void* data, VkDeviceSize dstOffset);
    void map(VkDeviceSize size, void* data);      // wrapper over upload()
    void remap(VkDeviceSize size, void* data);    // wrapper over upload()

    void destroy(const VkDevice& device);

    void bindAsVertexBuffer(VkCommandBuffer commandBuffer);
    void bindAsIndexBuffer(VkCommandBuffer commandBuffer);

    VkBuffer getVkBuffer();
    void* getUniformBuffer();                     // returns persistent mapped ptr

    VkDeviceSize getSizeInBytes();
    VkDeviceMemory getBufferMemory() { return m_VkBufferMemory; }

    // NOTE: still sync-submits a tiny one-time CB with a fence.
    // In a perf pass you’d batch this at frame level.
    void copyBuffer(VkBuffer srcBuffer, const VkCommandPool& commandPool,
        const VkDevice& device, VkDeviceSize size, const VkQueue& graphicsQueue);

    static uint32_t findMemoryType(VkPhysicalDevice physicalDevice,
        uint32_t typeFilter, VkMemoryPropertyFlags properties);

private:
    // Helpers
    bool isHostVisible()  const { return (m_Properties & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0; }
    bool isHostCoherent() const { return (m_Properties & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) != 0; }

    VkDevice m_VkDevice = VK_NULL_HANDLE;
    VkBuffer m_VkBuffer = VK_NULL_HANDLE;
    VkDeviceMemory m_VkBufferMemory = VK_NULL_HANDLE;
    VkDeviceSize m_Size = 0;

    // Persistent mapping
    VkMemoryPropertyFlags m_Properties{};
    void* m_Mapped = nullptr;
    VkDeviceSize m_NonCoherentAtomSize = 0;

    // Back-compat alias (some old code may still read this)
    void* m_UniformBufferMapped = nullptr;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\DataBuffer.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\DescriptorPool.h -----

#pragma once

#include <vector>
#include <memory>
#include <Engine/Graphics/DataBuffer.h>

class DescriptorPool
{
public:
	DescriptorPool() {};
	DescriptorPool(const VkDevice& device, VkDeviceSize size, size_t count);
	void Initialize(const VkDevice& device);

	void Destroy(const VkDevice& device);

	const VkDescriptorSetLayout& getDescriptorSetLayout()
	{
		return m_DescriptorSetLayout;
	}

	~DescriptorPool() ;
	void createDescriptorSets(const std::vector<VkBuffer>& buffers, const std::vector<std::vector<VkDescriptorImageInfo>>& images);

	void bindDescriptorSet(VkCommandBuffer buffer, VkPipelineLayout layout, size_t index);

private:
	VkDevice m_Device;
	VkDeviceSize m_Size;
	VkDescriptorPool m_DescriptorPool;
	std::vector<VkDescriptorSet> m_DescriptorSets;
	size_t m_Count;
	VkDescriptorSetLayout m_DescriptorSetLayout;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\DescriptorPool.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ImageDataBuffer.h -----


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ImageDataBuffer.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Material.h -----

#pragma once

#include <memory>
#include <string>
#include <Engine/Graphics/Texture.h>
#include <Engine/Graphics/TextureManager.h> // <-- Include this!
#include <atomic>

class Material {
public:
    Material(const std::string& albedoMapFileName = "",
        const std::string& normalMapFileName = "",
        const std::string& metalnessMapFileName = "",
        const std::string& roughnessMapFileName = "",
        const std::string& heightMapFileName = "");

    std::shared_ptr<Texture> getAlbedoMapTexture() const { return m_AlbedoMapTexture; }
    std::shared_ptr<Texture> getNormalMapTexture()  const { return m_NormalMapTexture; }
    std::shared_ptr<Texture> getMetalnessMapTexture()  const { return m_MetalnessMapTexture; }
    std::shared_ptr<Texture> getRoughnessMapTexture()  const { return m_RoughnessMapTexture; }
    std::shared_ptr<Texture> getHeightMapTexture()  const { return m_HeightMapTexture; }

    uint32_t getAlbedoMapID() const { return m_AlbedoMapTexture ? m_AlbedoMapTexture->getID() : UINT32_MAX; }
    uint32_t getNormalMapID() const { return m_NormalMapTexture ? m_NormalMapTexture->getID() : UINT32_MAX; }
    uint32_t getMetalnessMapID() const { return m_MetalnessMapTexture ? m_MetalnessMapTexture->getID() : UINT32_MAX; ; }
    uint32_t getRoughnessMapID() const { return m_RoughnessMapTexture ? m_RoughnessMapTexture->getID() : UINT32_MAX; ; }
    uint32_t getHeightMapID() const { return m_HeightMapTexture ? m_HeightMapTexture->getID() : UINT32_MAX; ; }

    std::vector<std::shared_ptr<Texture>> getAllTextures() const;

private:
    std::shared_ptr<Texture> m_AlbedoMapTexture;
    std::shared_ptr<Texture> m_NormalMapTexture;
    std::shared_ptr<Texture> m_MetalnessMapTexture;
    std::shared_ptr<Texture> m_RoughnessMapTexture;
    std::shared_ptr<Texture> m_HeightMapTexture;

};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Material.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\MaterialManager.h -----

#pragma once

#include <unordered_map>
#include <memory>
#include <string>
#include <vector>
#include <Engine/Graphics/Material.h>
#include <Engine/Graphics/Texture.h>
#include <Engine/Core/Singleton.h>

class MaterialManager : public Singleton<MaterialManager> {
public:
    // Get or create material by filepath (uses cache)
    std::shared_ptr<Material> getOrCreateMaterial(const std::string& filepath);

    // Standard material getter/setter
    void setStandardMaterial(const std::shared_ptr<Material>& material) { m_standardMaterial = material; }
    std::shared_ptr<Material> getStandardMaterial() const { return m_standardMaterial; }

    // Active materials getters/setters
    std::vector<std::shared_ptr<Material>>& getActiveMaterials() { return m_activeMaterials; }
    const std::vector<std::shared_ptr<Material>>& getActiveMaterials() const { return m_activeMaterials; }
    void setActiveMaterials(const std::vector<std::shared_ptr<Material>>& mats);

    // Add/remove material to/from active list (prevents duplicates)
    void addActiveMaterial(const std::shared_ptr<Material>& material);
    void removeActiveMaterial(const std::shared_ptr<Material>& material);

    // Find by ID or index (utility)
    std::shared_ptr<Material> getMaterialByID(uint32_t materialID) const;
    std::shared_ptr<Material> getMaterialByIndex(size_t idx) const;

    // Get number of active materials/textures
    size_t getNumActiveMaterials() const { return m_activeMaterials.size(); }

    // Clear active material list
    void clearActiveMaterials();

    // (Optional) Get all cached materials (not just active)
    std::vector<std::shared_ptr<Material>> getAllCachedMaterials() const;

    bool isTextureListDirty() const { return m_textureListDirty; }
    void clearTextureListDirty() { m_textureListDirty = false; }

private:
    friend class Singleton<MaterialManager>;
    MaterialManager();

    std::unordered_map<std::string, std::shared_ptr<Material>> m_materialCache;
    std::vector<std::shared_ptr<Material>> m_activeMaterials;
    std::shared_ptr<Material> m_standardMaterial;

    bool m_textureListDirty = true;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\MaterialManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Mesh.h -----

#pragma once

#include <vulkan\vulkan_core.h>
#include <Engine/Graphics/Vertex.h>
#include <glm/glm.hpp>
#include <Engine/Graphics/DataBuffer.h>
#include <Engine/Graphics/MeshData.h>
#include <Engine/Graphics/MaterialManager.h>
#include <memory>
class Mesh {
public:
	Mesh(const std::vector<Vertex>& Vertexes, const std::vector<uint32_t>& indices, const std::shared_ptr<Material> mat = {});
	void initialize(VkPhysicalDevice physicalDevice, VkDevice device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue);
	void destroyMesh(const VkDevice& device);

	void setPosition(glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles);
	glm::vec3 getPostion() { return m_Position; }
	void addVertex(glm::vec3 pos, glm::vec3 color, glm::vec3 normal);
	void addTriangle(uint32_t i1, uint32_t i2, uint32_t i3, uint32_t offset = 0);

	VkBuffer getVertexBuffer() const {
		// Replace getBuffer() with your DataBuffer accessor name if different
		return m_VertexBuffer ? m_VertexBuffer->getVkBuffer() : VK_NULL_HANDLE;
	}
	VkBuffer getIndexBuffer() const {
		return m_IndexBuffer ? m_IndexBuffer->getVkBuffer() : VK_NULL_HANDLE;
	}
	VkDeviceSize getVBOffset() const { return 0; } // if DataBuffer tracks offsets, return it here
	VkDeviceSize getIBOffset() const { return 0; }

	uint32_t getIndexCount() const { return static_cast<uint32_t>(m_Indices.size()); }

	const std::shared_ptr<Material>& getMaterial() const { return m_Material; }

	bool isInitialized() const { return m_VertexBuffer && m_IndexBuffer; }

	// Optional (handy later):
	const std::vector<Vertex>& cpuVertices() const { return m_Vertices; }
	const std::vector<uint32_t>& cpuIndices() const { return m_Indices; }
	void draw(VkPipelineLayout pipelineLayout, VkCommandBuffer commandBuffer);
private:
	std::vector<Vertex> m_Vertices;
	std::vector<uint32_t> m_Indices;
	std::unique_ptr<DataBuffer> m_VertexBuffer;
	std::unique_ptr<DataBuffer> m_IndexBuffer;

	MeshData m_VertexConstant;

	glm::vec3 m_Position = {};
	std::shared_ptr<Material> m_Material;
	void CreateVertexBuffer(VkPhysicalDevice physicalDevice, VkDevice device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue);
	void CreateIndexBuffer(VkPhysicalDevice physicalDevice, VkDevice device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue);
}; 

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Mesh.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\MeshData.h -----

#pragma once
#include <glm/glm.hpp>

struct MeshData {
    glm::mat4 model;
    uint32_t AlbedoID;
    uint32_t NormalMapID;
    uint32_t MetalnessID;
    uint32_t RoughnessID;
    uint32_t HeightMapID;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\MeshData.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Particle.h -----

#pragma once
#include <glm/glm.hpp>
#include <vulkan/vulkan_core.h>
#include <vector>

struct Particle {
	glm::vec4 pos;

	Particle(glm::vec4 p) { pos = p; }
	Particle() { pos = {}; }

	static VkVertexInputBindingDescription getBindingDescription() {
		VkVertexInputBindingDescription bindingDescription{};
		bindingDescription.binding = 0;
		bindingDescription.stride = sizeof(Particle);
		bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
		return bindingDescription;
	}

	static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions() {
		std::vector<VkVertexInputAttributeDescription> attributeDescriptions(1);

		attributeDescriptions[0].binding = 0;
		attributeDescriptions[0].location = 0;
		attributeDescriptions[0].format = VK_FORMAT_R32G32B32A32_SFLOAT;
		attributeDescriptions[0].offset = offsetof(Particle, pos);

		return attributeDescriptions;
	}

};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Particle.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ParticleGroup.h -----

#pragma once

#include <vulkan\vulkan_core.h>
#include <glm/glm.hpp>
#include <Engine/Graphics/DataBuffer.h>

#include <Engine/Graphics/vulkanVars.h>
#include <Engine/Graphics/MeshData.h>
#include <Engine/Graphics/Particle.h>
#include <memory>
#include <array>

#include <PxParticleBuffer.h>

#include <Engine/Graphics/ShaderBase.h>

class ParticleGroup {
public:
	ParticleGroup(physx::PxVec4* particleBuffer, int ParticleCount, const std::vector<Particle>& particles);
	void initialize(VkPhysicalDevice physicalDevice, VkDevice device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue);
	
	void setPosition(glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles);

	void destroyParticleGroup(const VkDevice& device);

	void draw(VkPipelineLayout pipelineLayout, VkCommandBuffer commandBuffer);
private:

	std::vector<Particle> m_Particles;
	std::array<std::unique_ptr<DataBuffer>, MAX_FRAMES_IN_FLIGHT> m_ParticleBuffers;

	MeshData m_VertexConstant = {  };
	physx::PxVec4* m_pParticleBuffer;
	int m_ParticleCount;
	void CreateParticleBuffer(VkPhysicalDevice physicalDevice, VkDevice device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue);

	void update();
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ParticleGroup.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Pipeline.h -----

#pragma once
#include <vector>
#include <memory>
#include <vulkan\vulkan_core.h>

#include <Engine/Graphics/ShaderBase.h>
#include <Engine/Graphics/CommandBuffer.h>
#include <Engine/Graphics/CommandPool.h>
#include <Engine/Scene/Scene.h>
#include <Engine/Graphics/UniformBufferObject.h>


struct PipelineConfig {
	VkRenderPass renderPass = VK_NULL_HANDLE;           // which render pass to build for
	VkPrimitiveTopology topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;

	// Depth state
	bool enableDepthTest = true;
	bool enableDepthWrite = true;

	// Vertex input: if false -> fullscreen/no-VB style
	bool useVertexInput = true;

	// Push constants: keep off for post
	bool usePushConstants = true;

	// If provided, Pipeline will use these instead of ShaderBase’s layout & sets.
	VkDescriptorSetLayout externalSetLayout = VK_NULL_HANDLE;
	const std::vector<VkDescriptorSet>* externalSets = nullptr;

	// If true, Record() draws a fullscreen triangle (3 verts) instead of Scene.
	bool fullscreenTriangle = false;
};

class Pipeline
{
public:
	Pipeline();
	~Pipeline();
	void Destroy(const VkDevice& vkDevice);
	void Initialize(const std::string& vertexShaderPath,
		const std::string& fragmentShaderPath,
		const VkVertexInputBindingDescription vkVertexInputBindingDesc,
		std::vector<VkVertexInputAttributeDescription> vkVertexInputAttributeDesc,
		const PipelineConfig& config);
	void Initialize(const std::string& vertexShaderPath, const std::string& fragmentShaderPath, const VkVertexInputBindingDescription vkVertexInputBindingDesc, std::vector<VkVertexInputAttributeDescription> vkVertexInputAttributeDesc, VkPrimitiveTopology topology);
	void Record(uint32_t imageIndex, VkRenderPass renderPass, const std::vector<VkFramebuffer>& swapChainFramebuffers, VkExtent2D swapChainExtent, Scene& scene);

	void setUbo(const UniformBufferObject& ubo) { m_Ubo = ubo; }
	void updateDescriptorSets();
	static VkFormat findDepthFormat(VkPhysicalDevice& vkPhysicalDevice, VkDevice& vkDevice);
	VkImage getDepthImage() { return m_DepthImage; };
	VkDeviceMemory getDepthImageMemory() { return m_DepthImageMemory; };
	VkImageView getDepthImageView() { return m_DepthImageView; };

private:
	void drawScene(uint32_t imageIndex, VkRenderPass renderPass, const std::vector<VkFramebuffer>& swapChainFramebuffers, VkExtent2D swapChainExtent, Scene& scene);

	void CreatePipeline(VkDevice device, VkRenderPass renderPass, VkPrimitiveTopology topology);

	VkPipeline m_Pipeline3d;
	std::unique_ptr<ShaderBase> m_Shader;
	PipelineConfig m_Config{};                  // NEW
	bool m_UseExternalDescriptors = false;      // NEW
	VkPipelineVertexInputStateCreateInfo m_EmptyVI{}; // NEW
	const VkPipelineVertexInputStateCreateInfo* pickVI(); // NEW
	UniformBufferObject m_Ubo{};

	VkPipelineLayout m_PipelineLayout;
	void updateUniformBuffer(uint32_t currentImage, VkExtent2D swapChainExtent);

	VkPushConstantRange createPushConstantRange();

	void createImage(VkPhysicalDevice& vkPhysicalDevice, VkDevice& vkDevice,uint32_t width, uint32_t height, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage& image, VkDeviceMemory& imageMemory);
	
	static VkFormat findSupportedFormat(VkPhysicalDevice& vkPhysicalDevice, VkDevice& vkDevice, const std::vector<VkFormat>& candidates, VkImageTiling tiling, VkFormatFeatureFlags features);
	void createDepthResources(VkPhysicalDevice& vkPhysicalDevice, VkDevice& vkDevice, VkExtent2D swapChainExtent);

	bool hasStencilComponent(VkFormat format);
	VkImageView createImageView(VkDevice& vkDevice, VkImage image, VkFormat format, VkImageAspectFlags aspectFlags);

	VkImage m_DepthImage;
	VkDeviceMemory m_DepthImageMemory;
	VkImageView m_DepthImageView;
};


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Pipeline.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\QueueFamilyIndices.h -----

#pragma once
#include <optional>

struct QueueFamilyIndices {
	std::optional<uint32_t> graphicsFamily;
	std::optional<uint32_t> presentFamily;

	bool isComplete() {
		return graphicsFamily.has_value() && presentFamily.has_value();
	}
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\QueueFamilyIndices.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\RendererManager.h -----

#pragma once

#include <vulkan/vulkan.h>
#include <GLFW/glfw3.h>
#include <Engine/Scene/Scene.h>
#include <Engine/Math/Camera.h>
#include <Engine/Graphics/Pipeline.h>
#include <Engine/Graphics/vulkanVars.h>
#include <Engine/Graphics/SwapChainSupportDetails.h>


#ifdef NDEBUG
const bool enableValidationLayers = false;
#else
const bool enableValidationLayers = true;
#endif

const std::vector<const char*> validationLayers = {
    "VK_LAYER_KHRONOS_validation"
};

const std::vector<const char*> deviceExtensions = {
    VK_KHR_SWAPCHAIN_EXTENSION_NAME
};

struct RenderStage {
    std::string name; // Optional, for debugging
    VkRenderPass renderPass;
    std::vector<VkFramebuffer>* framebuffers;
    std::vector<Pipeline*> pipelines;
    bool hasDepth = false; // NEW
};

struct OffscreenTarget {
    VkImage image = VK_NULL_HANDLE;
    VkDeviceMemory memory = VK_NULL_HANDLE;
    VkImageView view = VK_NULL_HANDLE;
};

struct DepthTarget {
    VkImage image = VK_NULL_HANDLE;
    VkDeviceMemory memory = VK_NULL_HANDLE;
    VkImageView view = VK_NULL_HANDLE;
};

struct RenderItem {
    Scene* scene;
    int pipelineIndex;
};

class RendererManager {
public:
    RendererManager();
    ~RendererManager();

    void Initialize();

   
    void RenderFrame(const std::vector<RenderItem>& renderItems, Camera& camera);

    void Cleanup();

private:
    Pipeline m_Pipeline3d;
    Pipeline m_PipelineParticles;
    Pipeline m_PipelinePostProcess;
    float m_RenderDistance{ 20.f };
    std::vector<RenderStage> m_RenderStages;

    VkRenderPass m_RenderPassOffscreen = VK_NULL_HANDLE; // scene (color+depth), final = COLOR_ATTACHMENT_OPTIMAL
    VkRenderPass m_RenderPassPresent = VK_NULL_HANDLE;  // post (color only), final = PRESENT_SRC_KHR
    std::vector<OffscreenTarget> m_OffscreenTargets;
    std::vector<VkFramebuffer>   m_OffscreenFramebuffers;
    VkDescriptorSetLayout m_PostSetLayout = VK_NULL_HANDLE;
    VkDescriptorPool      m_PostDescPool = VK_NULL_HANDLE;
    std::vector<VkDescriptorSet> m_PostDescSets;
    VkSampler             m_PostSampler = VK_NULL_HANDLE;
    VkSampler m_PostDepthSampler; // add a member
    std::vector<DepthTarget> m_OffscreenDepthTargets;

    void createRenderPasses();
    void createOffscreenTargets();
    void createFramebuffersOffscreen();
    void createFramebuffersPresent();
    void createPostDescriptors();

    void writePostDescriptors();

    void createOffscreenDepthTargets();

    VkSurfaceKHR surface;
    VkInstance instance;
    VkQueue presentQueue;
    VkSwapchainKHR swapChain;
    std::vector<VkImage> swapChainImages;
    VkFormat swapChainImageFormat;
    std::vector<VkImageView> swapChainImageViews;

    std::vector<VkFramebuffer> swapChainFramebuffers;
    std::array<VkSemaphore, MAX_FRAMES_IN_FLIGHT> imageAvailableSemaphores;
    std::vector<VkSemaphore> renderFinishedPerImage;
    std::array<VkFence, MAX_FRAMES_IN_FLIGHT> inFlightFences;

    std::vector<VkFence> imagesInFlight;

    void createInstance();
    bool checkValidationLayerSupport();
    std::vector<const char*> getRequiredExtensions();
    void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT& createInfo);

    void setupDebugMessenger();
    VkDebugUtilsMessengerEXT debugMessenger;

    void createSurface();

    void pickPhysicalDevice();
    bool isDeviceSuitable(VkPhysicalDevice device);
    bool checkDeviceExtensionSupport(VkPhysicalDevice device);
    void createLogicalDevice();

    void createSwapChain();
    SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device);
    VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats);
    VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR>& availablePresentModes);
    VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities);
    void createImageViews();


    void createRenderPass();

    void initPipeLines();
    void createFrameBuffers();

    void createSyncObjects(size_t currentFrame = 0);
    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device);


    static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData) {
        std::cerr << "validation layer: " << pCallbackData->pMessage << std::endl;
        return VK_FALSE;
    }
    VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger);
    void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator);

    void setupStages();
    // Offscreen render target
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\RendererManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ShaderBase.h -----

#pragma once
#ifndef SHADERBASE_H
#define SHADERBASE_H

#include <vulkan/vulkan.h>
#include <Engine/Graphics/Vertex.h>
#include <vector>
#include <string>
#include <memory>
#include <array>
#include <Engine/Graphics/DataBuffer.h>
#include <Engine/Graphics/DescriptorPool.h>
#include <Engine/Graphics/UniformBufferObject.h>

#include <memory>
#include <Engine/Graphics/Texture.h>

class ShaderBase {
public:
    ShaderBase() {};
    ShaderBase( const std::string& vertexShaderPath, const std::string& fragmentShaderPath);
    ~ShaderBase();

    void Destroy(const VkDevice& vkDevice);

    void initialize(const VkPhysicalDevice& vkPhysicalDevice, const VkDevice& vkDevice, const VkVertexInputBindingDescription& vkVertexInputBindingDesc, std::vector<VkVertexInputAttributeDescription>& vkVertexInputAttributeDesc);

    void createDescriptorSetLayout(const VkDevice& vkDevice);
    const VkDescriptorSetLayout& getDescriptorSetLayout()
    {
        return m_DescriptorSetLayout;
    }
    void bindDescriptorSet(VkCommandBuffer commandBuffer, VkPipelineLayout pipelineLayout, size_t index);

    void updateUniformBuffer(uint32_t currentImage, UniformBufferObject& ubo);
    void updateDescriptorSet();
    VkPipelineShaderStageCreateInfo getVertexShaderStageInfo() ;
    VkPipelineShaderStageCreateInfo getFragmentShaderStageInfo() ;
    VkPipelineVertexInputStateCreateInfo& getVertexInputStateInfo() ;
    VkPipelineInputAssemblyStateCreateInfo& getInputAssemblyStateInfo(VkPrimitiveTopology topology) ;

private:
    VkDevice device_{};
    std::vector<char> vertexShaderCode_{};
    std::vector<char> fragmentShaderCode_{};

    VkVertexInputBindingDescription m_VkVertexInputBindingDesc{};
    VkPipelineInputAssemblyStateCreateInfo m_VkPipelineInputAssemblyStateCreateInfo{};
    std::vector<VkVertexInputAttributeDescription> m_VkVertexInputAttributeDesc{};
       
    VkShaderModule vertexShaderModule_{};
    VkShaderModule fragmentShaderModule_{};

    VkPipelineVertexInputStateCreateInfo m_VertexInputStateInfo{};

    VkDescriptorSetLayout m_DescriptorSetLayout{};
    std::vector<std::unique_ptr<DataBuffer>> m_UBOBuffers{};

    UniformBufferObject m_UBOSrc{};
    DescriptorPool m_DescriptorPool{};


    std::vector<char> readFile(const std::string& filename);
    VkShaderModule createShaderModule(const std::vector<char>& code);

    //test
    std::shared_ptr<Texture> m_Tex;
};

#endif

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ShaderBase.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\SwapChainSupportDetails.h -----

#pragma once
#include <vulkan/vulkan_core.h>
#include <vector>


struct SwapChainSupportDetails {
	VkSurfaceCapabilitiesKHR capabilities;
	std::vector<VkSurfaceFormatKHR> formats;
	std::vector<VkPresentModeKHR> presentModes;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\SwapChainSupportDetails.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Texture.h -----

#pragma once

#include <vulkan/vulkan.h>
#include <string>
#include <atomic>

namespace {
    const std::string kErrorTexturePath = "Resources/Textures/errorTexture.jpg";
}

class Texture {
    friend class TextureManager;
public:
   
    ~Texture();

    VkImageView getImageView() const { return m_ImageView; }
    VkSampler getSampler() const { return m_Sampler; }
    VkDescriptorImageInfo getDescriptorInfo() const;

    uint32_t getID();
private:
    Texture(const std::string& filename);

    void createTextureImage(const std::string& filename);
    void createTextureImageView();
    void createTextureSampler();
    void transitionImageLayout(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout);
    void copyBufferToImage(VkBuffer buffer, VkImage image, uint32_t width, uint32_t height);

    VkImage m_Image = VK_NULL_HANDLE;
    VkDeviceMemory m_ImageMemory = VK_NULL_HANDLE;
    VkImageView m_ImageView = VK_NULL_HANDLE;
    VkSampler m_Sampler = VK_NULL_HANDLE;
    uint32_t m_Width = 0, m_Height = 0;
    uint32_t m_ID = -1;

    static std::atomic<uint32_t> s_NextID;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Texture.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\TextureManager.h -----

#pragma once

#include <unordered_map>
#include <memory>
#include <string>
#include <vector>
#include <Engine/Graphics/Texture.h>
#include <Engine/Core/Singleton.h>

class TextureManager : public Singleton<TextureManager> {
public:
    // Get or create texture by filepath (uses cache)
    std::shared_ptr<Texture> getOrCreateTexture(const std::string& filepath);

    // Standard texture getter/setter (e.g. a default white or error texture)
    void setStandardTexture(const std::shared_ptr<Texture>& texture) { m_standardTexture = texture; }
    std::shared_ptr<Texture> getStandardTexture() const { return m_standardTexture; }

    // Active textures getters/setters
    std::vector<std::shared_ptr<Texture>>& getActiveTextures() { return m_activeTextures; }
    const std::vector<std::shared_ptr<Texture>>& getActiveTextures() const { return m_activeTextures; }
    void setActiveTextures(const std::vector<std::shared_ptr<Texture>>& textures);

    // Add/remove texture to/from active list (prevents duplicates)
    void addActiveTexture(const std::shared_ptr<Texture>& texture);
    void removeActiveTexture(const std::shared_ptr<Texture>& texture);

    // Find by ID or index
    std::shared_ptr<Texture> getTextureByID(uint32_t textureID) const;
    std::shared_ptr<Texture> getTextureByIndex(size_t idx) const;

    // Get number of active textures
    size_t getNumActiveTextures() const { return m_activeTextures.size(); }

    // Clear active texture list
    void clearActiveTextures();

    // (Optional) Get all cached textures (not just active)
    std::vector<std::shared_ptr<Texture>> getAllCachedTextures() const;

    bool isTextureListDirty() const { return m_textureListDirty; }
    void clearTextureListDirty() { m_textureListDirty = false; }

private:
    friend class Singleton<TextureManager>;
    TextureManager();

    std::unordered_map<std::string, std::shared_ptr<Texture>> m_textureCache;
    std::vector<std::shared_ptr<Texture>> m_activeTextures;
    std::shared_ptr<Texture> m_standardTexture;

    bool m_textureListDirty = true;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\TextureManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\UniformBufferObject.h -----

#pragma once
#include <glm/glm.hpp>

struct UniformBufferObject {
	glm::mat4 proj;
	glm::mat4 view;
	glm::vec3 cameraPos;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\UniformBufferObject.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Vertex.h -----

#pragma once
#include <glm/glm.hpp>
#include <vulkan/vulkan_core.h>
#include <vector>

struct Vertex
{
	glm::vec3 pos;
	glm::vec3 normal;
	glm::vec3 color;
	glm::vec2 texCoord;

	Vertex(glm::vec3 pos, glm::vec3 normal, glm::vec3 color, glm::vec2 texCoord)
		:pos(pos), normal(normal), color(color), texCoord(texCoord)
	{
	}
	Vertex()
	{
		pos = {};
		normal = {};
		color = {};
	}

	static VkVertexInputBindingDescription getBindingDescription() {
		VkVertexInputBindingDescription bindingDescription{};
		bindingDescription.binding = 0;
		bindingDescription.stride = sizeof(Vertex);
		bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
		return bindingDescription;
	}

	static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions() {
		std::vector<VkVertexInputAttributeDescription> attributeDescriptions(4);

		attributeDescriptions[0].binding = 0;
		attributeDescriptions[0].location = 0;
		attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
		attributeDescriptions[0].offset = offsetof(Vertex, pos);

		attributeDescriptions[1].binding = 0;
		attributeDescriptions[1].location = 1;
		attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
		attributeDescriptions[1].offset = offsetof(Vertex, normal);

		attributeDescriptions[2].binding = 0;
		attributeDescriptions[2].location = 2;
		attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
		attributeDescriptions[2].offset = offsetof(Vertex, color);

		attributeDescriptions[3].binding = 0;
		attributeDescriptions[3].location = 3;
		attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
		attributeDescriptions[3].offset = offsetof(Vertex, texCoord);

		return attributeDescriptions;
	}
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Vertex.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\vulkanVars.h -----

#pragma once

#include <Engine/Core/Singleton.h>
#include <Engine/Graphics/CommandBuffer.h>
#include <Engine/Graphics/CommandPool.h>

const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;
const int MAX_FRAMES_IN_FLIGHT = 3;
const int MAX_TEXTURES = 32;

class vulkanVars : public Singleton<vulkanVars> {
public:
	CommandPool commandPoolModelPipeline{};
	CommandPool commandPoolParticlesPipeline{};
	VkDevice device = VK_NULL_HANDLE;
	VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
	VkRenderPass renderPass = VK_NULL_HANDLE;
	VkQueue graphicsQueue = VK_NULL_HANDLE;
	VkExtent2D swapChainExtent;
	std::vector<CommandBuffer> commandBuffers; 
	size_t currentFrame = 0;
};



----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\vulkanVars.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Input\InputManager.h -----

#pragma once
#include <GLFW/glfw3.h>
#include <vector>
#include <Engine/Math/Camera.h>

class InputManager {
public:
    static InputManager& GetInstance();

    void Initialize(GLFWwindow* window);

    bool IsKeyDown(int key) const;
    bool IsMouseButtonDown(int button) const;
    double GetMouseX() const;
    double GetMouseY() const;

    void Update();

    void HandleCameraInputs(Camera* camera, float deltaTime);
private:
    InputManager();
    ~InputManager();

    InputManager(const InputManager&) = delete;
    InputManager& operator=(const InputManager&) = delete;
    InputManager(InputManager&&) = delete;
    InputManager& operator=(InputManager&&) = delete;

    std::vector<int> keysDown;
    std::vector<int> mouseButtonsDown;
    double mouseX;
    double mouseY;

    glm::vec2 m_LastMousePos;

    static void KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);
    static void MouseButtonCallback(GLFWwindow* window, int button, int action, int mods);
    static void CursorPosCallback(GLFWwindow* window, double xpos, double ypos);
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Input\InputManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Math\Camera.h -----

#pragma once
#include <cassert>
#include <iostream>

#include <glm/vec3.hpp> 
#include <glm/vec4.hpp> 
#include <glm/mat4x4.hpp> 
#include <glm/ext/matrix_transform.hpp> 
#include <glm/ext/matrix_clip_space.hpp> 
#include <glm/ext/scalar_constants.hpp>

struct Camera
{
	Camera() = default;

	Camera(const glm::vec3& _origin, float _fovAngle, float _aspectRatio);


	glm::vec3 origin{};
	float fovAngle{ 90.f };
	float fov{ glm::radians(fovAngle)};
	float aspectRatio{1.f};

	float nearPlane{ 0.1f };
	float farPlane{ 100.f };

	glm::vec3 forward{ 0.f,0.f,1.f };
	glm::vec3 up{ 0.f,1.f,0.f };
	glm::vec3 right{ 1.f,0.f,0.f };

	float totalPitch{ 0.f};
	float totalYaw{};

	glm::mat4 invViewMatrix{};
	glm::mat4 viewMatrix{};

	glm::mat4 projectionMatrix{};

	void Initialize(float _fovAngle = 90.f, glm::vec3 _origin = { 0.f,0.f,0.f }, float _aspectRatio = 1.f);

	void CalculateViewMatrix();
	void CalculateProjectionMatrix();

	glm::mat4 CalculateCameraToWorld();
	void printValuesCamera();
	
	void update();

	void rotate(glm::vec2 offset);
	void translateForward(float posChange);
	void translateRight(float posChange);

	void SetFov(const float fovAngleNew);
	void SetAspectRatio(const float aspect);

	glm::mat4 CreateRotationX(float pitch) {
		return glm::rotate(glm::mat4(1.0f), pitch, glm::vec3(1.0f, 0.0f, 0.0f));
	}

	glm::mat4 CreateRotationY(float yaw) {
		return glm::rotate(glm::mat4(1.0f), yaw, glm::vec3(0.0f, 1.0f, 0.0f));
	}

	glm::mat4 CreateRotationZ(float roll) {
		return glm::rotate(glm::mat4(1.0f), roll, glm::vec3(0.0f, 0.0f, 1.0f));
	}

};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Math\Camera.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\ObjUtils\ObjUtils.h -----

#include "fast_obj.h"
#include <unordered_map>
#include <tuple>

// Key = (p,t,n) triplet into fast_obj buffers
struct Triplet {
    uint32_t p, t, n;
    bool operator==(const Triplet& o) const { return p == o.p && t == o.t && n == o.n; }
};
struct TripletHash {
    size_t operator()(const Triplet& k) const noexcept {
        size_t h = 1469598103934665603ull;
        auto mix = [&](uint64_t x) { h ^= x + 0x9e3779b97f4a7c15ull + (h << 6) + (h >> 2); };
        mix(k.p); mix(k.t); mix(k.n); return h;
    }
};

// Fill your vertex/index arrays from a .obj
// flipV : keep false if your textures are already “V up”; true if you need v = 1 - v.
// flipWinding : swap i1<->i2 per triangle if your pipeline expects opposite winding.
bool ParseOBJ(const char* path,
    std::vector<Vertex>& outVertices,
    std::vector<uint32_t>& outIndices,
    bool flipV = false,
    bool flipWinding = false)
{
    fastObjMesh* m = fast_obj_read(path);
    if (!m) return false;

    // --- Pre-pass stats (before you touch outVertices/outIndices) ---
    {
        size_t triTotal = 0, idxTotal = 0, nTri = 0, nQuad = 0, nNgon = 0;
        for (unsigned f = 0; f < m->face_count; ++f) {
            unsigned fv = m->face_vertices[f];
            if (fv >= 3) {
                triTotal += (fv - 2);
                idxTotal += 3 * (fv - 2);
                if (fv == 3) ++nTri;
                else if (fv == 4) ++nQuad;
                else if (fv > 4) ++nNgon;
            }
        }
        std::cout << "faces=" << m->face_count
            << "  tris=" << triTotal
            << "  indices=" << idxTotal
            << "  (tri=" << nTri
            << ", quad=" << nQuad
            << ", ngon=" << nNgon << ")\n";
    }

    outVertices.clear();
    outIndices.clear();
    outVertices.reserve(m->index_count); // upper bound

    std::unordered_map<Triplet, uint32_t, TripletHash> cache;
    cache.reserve(m->index_count);

    // Iterate faces; m->face_vertices[i] = polygon size of face i
    size_t idxCursor = 0;
    for (unsigned f = 0; f < m->face_count; ++f) {
        unsigned fv = m->face_vertices[f]; // 3 for tri, 4 for quad, etc.

        // Grab all corners (Triplet list)
        std::vector<uint32_t> cornerIdx; cornerIdx.reserve(fv);
        auto emitVertex = [&](const fastObjIndex& ix) -> uint32_t {
            Triplet key{ ix.p, ix.t, ix.n }; // note: 1-based or 0 if missing
            auto it = cache.find(key);
            if (it != cache.end()) return it->second;

            Vertex v{};
            v.color = glm::vec3(1.0f);
            // Position
            if (ix.p) {
                const float* P = &m->positions[3 * (ix.p - 1)];
                v.pos = glm::vec3(P[0], P[1], P[2]);
            }
            else {
                v.pos = glm::vec3(0);
            }
            // UV
            if (ix.t) {
                const float* T = &m->texcoords[2 * (ix.t - 1)];
                v.texCoord = glm::vec2(T[0], flipV ? (1.0f - T[1]) : T[1]);
            }
            else {
                v.texCoord = glm::vec2(0);
            }
            // Normal
            if (ix.n) {
                const float* N = &m->normals[3 * (ix.n - 1)];
                v.normal = glm::vec3(N[0], N[1], N[2]);
            }
            else {
                v.normal = glm::vec3(0, 1, 0);
            }

            uint32_t newIndex = static_cast<uint32_t>(outVertices.size());

            outVertices.push_back(v);
            cache.emplace(key, newIndex);
            return newIndex;
            };

        // Build corner list
        for (unsigned k = 0; k < fv; ++k) {
            const fastObjIndex ix = m->indices[idxCursor + k];
            cornerIdx.push_back(emitVertex(ix));
        }

        // Triangulate as fan: (0, i, i+1)
        for (unsigned i = 1; i + 1 < fv; ++i) {
            uint32_t i0 = cornerIdx[0];
            uint32_t i1 = cornerIdx[i];
            uint32_t i2 = cornerIdx[i + 1];
            if (flipWinding) std::swap(i1, i2);
            outIndices.push_back(i0);
            outIndices.push_back(i1);
            outIndices.push_back(i2);
        }

        idxCursor += fv;
    }

    fast_obj_destroy(m);
    return true;
}

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\ObjUtils\ObjUtils.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Physics\PhysicsManager.h -----

#pragma once
#include <PxPhysicsAPI.h>
#include "PhysxBase.h"
using namespace physx;

class PhysicsManager {
public:
    static PhysicsManager& GetInstance() {
        static PhysicsManager instance;
        return instance;
    }

    void Initialize();

    void StepPhysics(float deltaTime);

    void Cleanup();

private:
    PhysicsManager() = default;
    ~PhysicsManager() = default;
    PhysicsManager(const PhysicsManager&) = delete;
    PhysicsManager& operator=(const PhysicsManager&) = delete;

};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Physics\PhysicsManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Physics\PhysxBase.h -----

#pragma once

#include <vector>
#include <PxPhysicsAPI.h>
#include <extensions/PxParticleExt.h>
#include <Engine/Graphics/Particle.h>
#include <Engine/Core/Singleton.h>
#include <Engine/Graphics/DataBuffer.h>


using namespace physx;
using namespace ExtGpu;

// Forward declarations
class PxCudaContextManager;

class PhysxBase : public Singleton<PhysxBase>
{
public:
    PhysxBase();
    ~PhysxBase();

    void initPhysics(bool useLargeFluid);
    void stepPhysics(bool interactive, float deltaTime);
    void cleanupPhysics(bool interactive);
    float getRightWallLocation();
    std::vector<Particle>& getParticles();

    PxPBDParticleSystem* getParticleSystem();
    PxParticleAndDiffuseBuffer* getParticleBuffer();

    // Wall movement controls
    bool wallMoveLeft = false;
    bool wallMoveRight = false;

private:
    void initObstacles();
    void initScene();
    void initParticles(PxU32 numX, PxU32 numY, PxU32 numZ, const PxVec3& position, PxReal particleSpacing, PxReal fluidDensity, PxU32 maxDiffuseParticles);
    void getParticlesInternal();

    // PhysX SDK objects
    physx::PxFoundation* mFoundation = nullptr;
    physx::PxPhysics* mPhysics = nullptr;
    physx::PxDefaultCpuDispatcher* mDispatcher = nullptr;
    physx::PxScene* mScene = nullptr;
    physx::PxMaterial* mMaterial = nullptr;
    physx::PxPvd* mPvd = nullptr;
    physx::PxCudaContextManager* mCudaContextManager = nullptr; // <-- FULLY QUALIFIED
    physx::PxPBDParticleSystem* mParticleSystem = nullptr;
    physx::PxParticleAndDiffuseBuffer* mParticleBuffer = nullptr;
    physx::PxRigidDynamic* mMovingWall = nullptr;

    int mMaxDiffuseParticles = 0;
    bool mIsRunning = true;
    bool mStep = true;

    std::vector<Particle> m_Particles;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Physics\PhysxBase.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\PlatformVulkanSurface.h -----

#pragma once

#include "vulkan\vulkan_core.h"
#include <Engine/Platform/PlatformWindow.h>

class PlatformVulkanSurface {
public:
    virtual ~PlatformVulkanSurface() {}
    virtual VkSurfaceKHR createSurface(VkInstance instance, PlatformWindow* window) = 0;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\PlatformVulkanSurface.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\PlatformWindow.h -----

#pragma once

class PlatformWindow {
public:
    virtual ~PlatformWindow() {}
    virtual void* getNativeHandle() = 0;
    virtual bool shouldClose() const = 0;
    virtual void pollEvents() = 0;
    virtual void getFramebufferSize(int& width, int& height) const = 0;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\PlatformWindow.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Linux\PlatformWindow_Linux.h -----

#pragma once

#ifdef __linux__

#include <GLFW/glfw3.h>
#include <Engine/Platform/PlatformWindow.h>

class PlatformWindow_Linux : public PlatformWindow {
public:
    PlatformWindow_Linux(int width, int height, const char* title);
    ~PlatformWindow_Linux();

    void getFramebufferSize(int& width, int& height) const override {
        glfwGetFramebufferSize(m_window, &width, &height);
    }
    void* getNativeHandle() override;
    GLFWwindow* getGLFWwindow() const { return m_window; }

    bool shouldClose() const override;
    void pollEvents() override;

private:
    GLFWwindow* m_window;
};

#endif 

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Linux\PlatformWindow_Linux.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Linux\VulkanSurface_Linux.h -----

#pragma once
#ifdef __linux__

#include "../PlatformVulkanSurface.h"

class VulkanSurface_Linux : public PlatformVulkanSurface {
public:
    VkSurfaceKHR createSurface(VkInstance instance, PlatformWindow* window) override;
};

#endif 

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Linux\VulkanSurface_Linux.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Windows\PlatformWindow_Windows.h -----

#pragma once

#ifdef _WIN32


#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif

#include <GLFW/glfw3.h>
#include <Engine/Platform/PlatformWindow.h>

class PlatformWindow_Windows : public PlatformWindow {
public:
    PlatformWindow_Windows(int width, int height, const char* title);
    ~PlatformWindow_Windows();
    void getFramebufferSize(int& width, int& height) const override {
        glfwGetFramebufferSize(m_window, &width, &height);
    }
    void* getNativeHandle() override;

    GLFWwindow* getGLFWwindow() const { return m_window; }

    bool shouldClose() const override;
    void pollEvents() override;

private:
    GLFWwindow* m_window;
};

#endif 

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Windows\PlatformWindow_Windows.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Windows\VulkanSurface_Windows.h -----

#pragma once
#ifdef _WIN32

#include "../PlatformVulkanSurface.h"
class VulkanSurface_Windows : public PlatformVulkanSurface {
public:
    VkSurfaceKHR createSurface(VkInstance instance, PlatformWindow* window) override;
};
#endif

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Windows\VulkanSurface_Windows.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\ChunkGrid.h -----

#pragma once
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <glm/glm.hpp>
#include "MeshKeyUtil.h"


struct ChunkCoord { int x, y, z; };
inline bool operator==(const ChunkCoord& a, const ChunkCoord& b) {
    return a.x == b.x && a.y == b.y && a.z == b.z;
}
struct ChunkCoordHash {
    size_t operator()(const ChunkCoord& c) const noexcept {
        size_t h = 1469598103934665603ull;
        auto mix = [&](int v) { h ^= (size_t)v + 0x9e3779b97f4a7c15ull + (h << 6) + (h >> 2); };
        mix(c.x); mix(c.y); mix(c.z); return h;
    }
};

//class BaseObject;


struct Chunk {
    std::unordered_map<MeshKey, std::vector<BaseObject*>, MeshKeyHash> batches;
};

enum class SpatialTag : uint8_t { SingleChunk, MultiChunk, Global };

struct SpatialInfo {
    SpatialTag tag = SpatialTag::SingleChunk;
    glm::vec3  halfExtents{ 0.0f }; // for MultiChunk, AABB half-extents in world space

    bool       overrideEnabled = false;
    glm::vec3  overrideCenter{ 0.0f };
    glm::vec3  overrideHalfExtents{ 0.0f };
};

struct BatchRef {
    ChunkCoord chunk{};
    size_t     indexInBatch{};
};

// NOTE: This is the ONLY ObjectHandle definition
struct ObjectHandle {
    MeshKey key{};
    bool    isGlobal = false;
    std::vector<BatchRef> perChunkRefs; // empty for global
    size_t  globalIndex = SIZE_MAX;     // valid only if isGlobal==true
};



class ChunkGrid {
public:
    explicit ChunkGrid(float chunkSize = 32.f) : m_chunkSize(chunkSize) {}

    void setCulling(const glm::vec3& camPos, float renderDistance) {
        m_camPos = camPos; m_renderDistance = renderDistance;
        m_chunkRadius = (int)glm::ceil(renderDistance / m_chunkSize);
    }

    void add(BaseObject* obj, const MeshKey& key) {
        // If spatial info not set yet, default SingleChunk
        (void)m_spatial[obj];
        insertAccordingToSpatial(obj, key);
    }

    void remove(BaseObject* obj) {
        auto it = m_handles.find(obj);
        if (it == m_handles.end()) return;

        ObjectHandle h = it->second;
        if (h.isGlobal) {
            auto gIt = m_globalBatches.find(h.key);
            if (gIt != m_globalBatches.end()) {
                auto& vec = gIt->second;
                size_t last = vec.size() - 1;
                std::swap(vec[h.globalIndex], vec[last]);
                BaseObject* moved = vec[h.globalIndex];
                if (moved) m_handles[moved].globalIndex = h.globalIndex;
                vec.pop_back();
                if (vec.empty()) m_globalBatches.erase(gIt);
            }
        }
        else {
            // Remove from every chunk batch we’re in
            for (const BatchRef& ref : h.perChunkRefs) {
                auto chIt = m_chunks.find(ref.chunk);
                if (chIt == m_chunks.end()) continue;
                auto bIt = chIt->second.batches.find(h.key);
                if (bIt == chIt->second.batches.end()) continue;
                auto& vec = bIt->second;
                size_t last = vec.size() - 1;
                std::swap(vec[ref.indexInBatch], vec[last]);
                BaseObject* moved = vec[ref.indexInBatch];
                if (moved) {
                    // Fix moved element’s BatchRef pointing to this same chunk/key
                    auto& mh = m_handles[moved];
                    for (auto& mref : mh.perChunkRefs) {
                        if (mref.chunk.x == ref.chunk.x && mref.chunk.y == ref.chunk.y && mref.chunk.z == ref.chunk.z) {
                            mref.indexInBatch = ref.indexInBatch;
                            break;
                        }
                    }
                }
                vec.pop_back();
                if (vec.empty()) chIt->second.batches.erase(h.key);
                if (chIt->second.batches.empty()) m_chunks.erase(chIt);
            }
        }
        m_handles.erase(it);
    }

    // call when obj moved or changed material/mesh
    void update(BaseObject* obj, const MeshKey& newKey) {
        auto it = m_handles.find(obj);
        if (it == m_handles.end()) { add(obj, newKey); return; }
        // Simple + safe: remove + reinsert (keeps logic centralized)
        remove(obj);
        insertAccordingToSpatial(obj, newKey);
    }

    void setCoverageOverride(BaseObject* obj, const glm::vec3& center, const glm::vec3& halfExtents) {
        SpatialInfo& s = m_spatial[obj];
        s.overrideEnabled = true;
        s.overrideCenter = center;
        s.overrideHalfExtents = halfExtents;
        auto it = m_handles.find(obj);
        if (it != m_handles.end()) update(obj, it->second.key); // reinsert with new coverage
    }

    // Remove coverage override (falls back to Single/Multi behavior)
    void clearCoverageOverride(BaseObject* obj) {
        SpatialInfo& s = m_spatial[obj];
        if (!s.overrideEnabled) return;
        s.overrideEnabled = false;
        auto it = m_handles.find(obj);
        if (it != m_handles.end()) update(obj, it->second.key);
    }

    template<typename Fn>
    void forVisibleBatches(Fn&& fn) {
        std::unordered_set<BaseObject*> visited;

        // visible chunks
        ChunkCoord cc = toChunk(m_camPos);
        for (int z = -m_chunkRadius; z <= m_chunkRadius; ++z)
            for (int y = -m_chunkRadius; y <= m_chunkRadius; ++y)
                for (int x = -m_chunkRadius; x <= m_chunkRadius; ++x) {
                    ChunkCoord c{ cc.x + x, cc.y + y, cc.z + z };
                    auto it = m_chunks.find(c);
                    if (it == m_chunks.end()) continue;

                    // sphere-ish cutoff
                    glm::vec3 center = fromChunk(c);
                    if (glm::distance(center, m_camPos) > (m_chunkRadius + 0.5f) * m_chunkSize) continue;

                    for (auto& kv : it->second.batches) {
                        const MeshKey& key = kv.first;
                        const auto& vec = kv.second;
                        if (vec.empty()) continue;

                        // filter out duplicates (multi-chunk objects may appear in several chunks)
                        std::vector<BaseObject*> unique;
                        unique.reserve(vec.size());
                        for (BaseObject* o : vec) {
                            if (visited.insert(o).second) unique.push_back(o);
                        }
                        if (!unique.empty()) fn(key, unique);
                    }
                }

        // always-visible globals (no need to dedup: they are not in chunks)
        for (auto& kv : m_globalBatches) {
            if (!kv.second.empty()) fn(kv.first, kv.second);
        }
    }

    float chunkSize() const { return m_chunkSize; }

    void setGlobal(BaseObject* obj, bool enable) {
        SpatialInfo& s = m_spatial[obj];
        s.tag = enable ? SpatialTag::Global : SpatialTag::SingleChunk;
        // If already registered, reinsert with new behavior
        auto it = m_handles.find(obj);
        if (it != m_handles.end()) {
            MeshKey k = it->second.key;
            update(obj, k);
        }
    }

    // Mark as multi-chunk with world half-extents (axis-aligned); set (0,0,0) to revert to single-chunk
    void setMultiChunk(BaseObject* obj, const glm::vec3& halfExtents) {
        SpatialInfo& s = m_spatial[obj];
        s.halfExtents = halfExtents;
        s.tag = (glm::any(glm::greaterThan(halfExtents, glm::vec3(0.0f))))
            ? SpatialTag::MultiChunk
            : SpatialTag::SingleChunk;
        auto it = m_handles.find(obj);
        if (it != m_handles.end()) {
            MeshKey k = it->second.key;
            update(obj, k);
        }
    }

private:
    // You already have BaseObject::getPosition()
    static glm::vec3 getPos(const BaseObject* obj);

    // Insert based on SpatialInfo tag (used by add/update)
    void insertAccordingToSpatial(BaseObject* obj, const MeshKey& key) {
        const SpatialInfo& s = m_spatial[obj];
        ObjectHandle handle;
        handle.key = key;

        if (s.tag == SpatialTag::Global) {
            auto& vec = m_globalBatches[key];
            vec.push_back(obj);
            handle.isGlobal = true;
            handle.globalIndex = vec.size() - 1;
            m_handles[obj] = std::move(handle);
            return;
        }

        // Single or Multi: compute chunk list
        glm::vec3 C;
        glm::vec3 he;

        if (s.overrideEnabled) {
            C = s.overrideCenter;
            he = s.overrideHalfExtents;
        }
        else {
            C = getPos(obj);
            he = (s.tag == SpatialTag::MultiChunk) ? s.halfExtents : glm::vec3(0.0f);
        }
        glm::vec3 minP = C - he;
        glm::vec3 maxP = C + he;
        ChunkCoord minC = toChunk(minP);
        ChunkCoord maxC = toChunk(maxP);

        // clamp to reasonable range if needed; here we trust data
        for (int z = minC.z; z <= maxC.z; ++z)
            for (int y = minC.y; y <= maxC.y; ++y)
                for (int x = minC.x; x <= maxC.x; ++x) {
                    ChunkCoord c{ x,y,z };
                    auto& vec = m_chunks[c].batches[key];
                    vec.push_back(obj);
                    handle.perChunkRefs.push_back(BatchRef{ c, vec.size() - 1 });
                }

        handle.isGlobal = false;
        m_handles[obj] = std::move(handle);
    }

    ChunkCoord toChunk(const glm::vec3& p) const {
        return ChunkCoord{ (int)glm::floor(p.x / m_chunkSize),
                           (int)glm::floor(p.y / m_chunkSize),
                           (int)glm::floor(p.z / m_chunkSize) };
    }
    glm::vec3 fromChunk(const ChunkCoord& c) const {
        return { (c.x + 0.5f) * m_chunkSize, (c.y + 0.5f) * m_chunkSize, (c.z + 0.5f) * m_chunkSize };
    }


    float m_chunkSize{ 32.f };
    glm::vec3 m_camPos{ 0 };
    float m_renderDistance{ 128.f };
    int m_chunkRadius{ 4 };

    std::unordered_map<ChunkCoord, Chunk, ChunkCoordHash> m_chunks;
    std::unordered_map<MeshKey, std::vector<BaseObject*>, MeshKeyHash> m_globalBatches;
    std::unordered_map<BaseObject*, ObjectHandle> m_handles;
    std::unordered_map<BaseObject*, SpatialInfo>  m_spatial;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\ChunkGrid.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameSceneManager.h -----

#pragma once
#include <vector>
#include <memory>
#include "Gameobjects/GameObject.h"

class GameSceneManager {
public:
    static GameSceneManager& getInstance() {
        static GameSceneManager instance;
        return instance;
    }
    GameObject* addGameObject() {
        auto obj = std::make_unique<GameObject>();
        GameObject* rawPtr = obj.get();
        m_gameObjects.push_back(std::move(obj));
        return rawPtr;
    }
    void initialize() {
        for (auto& obj : m_gameObjects)
            obj->initialize();
    }

    void update() {
        for (auto& obj : m_gameObjects)
            obj->update();
    }

    void render() {
        for (auto& obj : m_gameObjects)
            obj->render();
    }

private:
    GameSceneManager() = default;
    ~GameSceneManager() = default;
    GameSceneManager(const GameSceneManager&) = delete;
    GameSceneManager& operator=(const GameSceneManager&) = delete;

    std::vector<std::unique_ptr<GameObject>> m_gameObjects;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameSceneManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\MeshKeyUtil.h -----

#pragma once
#include <vulkan/vulkan_core.h>
#include <cstdint>
#include <functional>

// Forward declare to avoid heavy includes first
class BaseObject;

struct MeshKey {
    VkBuffer vertexBuffer{};
    VkDeviceSize vbOffset{};
    VkBuffer indexBuffer{};
    VkDeviceSize ibOffset{};
    uint32_t indexCount{};
    const void* materialPtr{};
    uint32_t pipelineIndex{};

    uint64_t logicalId{ 0 };

    bool operator==(const MeshKey& o) const {
        return vertexBuffer == o.vertexBuffer && vbOffset == o.vbOffset &&
            indexBuffer == o.indexBuffer && ibOffset == o.ibOffset &&
            indexCount == o.indexCount && materialPtr == o.materialPtr &&
            pipelineIndex == o.pipelineIndex;
    }
};

struct MeshKeyHash {
    size_t operator()(const MeshKey& k) const noexcept {
        auto h = std::hash<uint64_t>{}(reinterpret_cast<uint64_t>(k.vertexBuffer));
        h ^= std::hash<uint64_t>{}(reinterpret_cast<uint64_t>(k.indexBuffer)) + 0x9e3779b9 + (h << 6) + (h >> 2);
        h ^= std::hash<uint64_t>{}(k.vbOffset) + 0x85ebca6b + (h << 6) + (h >> 2);
        h ^= std::hash<uint64_t>{}(k.ibOffset) + 0xc2b2ae35 + (h << 6) + (h >> 2);
        h ^= std::hash<uint32_t>{}(k.indexCount) + (h << 6) + (h >> 2);
        h ^= std::hash<uint64_t>{}(reinterpret_cast<uint64_t>(k.materialPtr)) + (h << 6) + (h >> 2);
        h ^= std::hash<uint32_t>{}(k.pipelineIndex);
        h ^= std::hash<uint64_t>{}(k.logicalId);
        return h;
    }
};


#include <Engine/Scene/GameObjects/BaseObject.h>

inline MeshKey MakeMeshKey(const BaseObject* obj, uint32_t pipelineIndex) {
    return MeshKey{
        obj->getVertexBuffer(),
        obj->getVBOffset(),
        obj->getIndexBuffer(),
        obj->getIBOffset(),
        obj->getIndexCount(),
        obj->getMaterial().get(),
        pipelineIndex,
        obj->getLogicalGroupId()   // << NEW
    };
}

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\MeshKeyUtil.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\MeshScene.h -----

#pragma once

#define GLM_ENABLE_EXPERIMENTAL

#include <vulkan\vulkan_core.h>
#include <glm/glm.hpp>
#include <Engine/Graphics/Mesh.h>
#include <Engine/Scene/GameObjects/BaseObject.h>
#include <Engine/Scene/Scene.h>
#include <glm\gtx\quaternion.hpp>
#include "MeshKeyUtil.h"
#include "ChunkGrid.h"

static inline void basisFromNormal(const glm::vec3& nIn,
    glm::vec3& t, glm::vec3& b, glm::vec3& n)
{
    n = glm::normalize(nIn);
    // Choose an up reference that isn't parallel to n
    glm::vec3 up = (std::abs(n.y) > 0.999f) ? glm::vec3(0, 0, 1) : glm::vec3(0, 1, 0);
    t = glm::normalize(glm::cross(up, n)); // tangent (? width axis)
    b = glm::cross(n, t);                  // bitangent (? height axis)
}

enum class ObjType {
    plane,
    model
};


class MeshScene : public Scene{
public:
    explicit MeshScene(float chunkSize = 32.f) : m_chunks(chunkSize) {}


    void setObjectCoverageOverride(BaseObject* obj, glm::vec3 center, glm::vec3 halfExtents) {
        m_chunks.setCoverageOverride(obj, center, halfExtents);
    }
    void clearObjectCoverageOverride(BaseObject* obj) {
        m_chunks.clearCoverageOverride(obj);
    }

    unsigned int addModel(const std::vector<Vertex>& Vertexes, const std::vector<uint32_t>& indices, glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles, const std::shared_ptr<Material> mat = {})
    {
        BaseObject* object = new BaseObject{ Vertexes, indices, mat };
        object->setPosition(position, scale, rotationAngles);
        m_BaseObjects.push_back(object);
        m_pendingToRegister.push_back(object);
        return static_cast<unsigned int>(m_BaseObjects.size() - 1);
    }

    void setObjectGlobal(BaseObject* obj, bool enable) { m_chunks.setGlobal(obj, enable); }
    void setObjectMultiChunk(BaseObject* obj, glm::vec3 halfExtents) { m_chunks.setMultiChunk(obj, halfExtents); }

    void setObjectGlobal(unsigned int idx, bool enable) {
        if (idx < m_BaseObjects.size()) m_chunks.setGlobal(m_BaseObjects[idx], enable);
    }
    void setObjectMultiChunk(unsigned int idx, glm::vec3 halfExtents) {
        if (idx < m_BaseObjects.size()) m_chunks.setMultiChunk(m_BaseObjects[idx], halfExtents);
    }

    BaseObject* getBaseObject(unsigned int modelId)
    {
        if (modelId < m_BaseObjects.size())
        {
            return m_BaseObjects[modelId];
        }
        return nullptr;
    }

    unsigned int addRectangle(const glm::vec3& normal,
        const glm::vec3& color,
        float width, float height,
        glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles,
        const std::shared_ptr<Material> mat = {})
    {
        float halfW = width * 0.5f;
        float halfH = height * 0.5f;

        // Build a stable local frame from the normal
        glm::vec3 T, B, N;
        basisFromNormal(normal, T, B, N);

        // Positions in that frame: X?T (width), Y?B (height), Z along N
        glm::vec3 p0 = (-halfW) * T + (-halfH) * B; // bottom-left
        glm::vec3 p1 = (+halfW) * T + (-halfH) * B; // bottom-right
        glm::vec3 p2 = (+halfW) * T + (+halfH) * B; // top-right
        glm::vec3 p3 = (-halfW) * T + (+halfH) * B; // top-left

        glm::vec2 uv0(0.0f, 0.0f);
        glm::vec2 uv1(1.0f, 0.0f);
        glm::vec2 uv2(1.0f, 1.0f);
        glm::vec2 uv3(0.0f, 1.0f);

        std::vector<Vertex> vertices;
        std::vector<uint32_t> indices;

        vertices.push_back({ p0, N, color, uv0 });
        vertices.push_back({ p1, N, color, uv1 });
        vertices.push_back({ p2, N, color, uv2 });
        vertices.push_back({ p3, N, color, uv3 });

        uint32_t base = 0;
        indices.push_back(base + 0);
        indices.push_back(base + 1);
        indices.push_back(base + 2);
        indices.push_back(base + 0);
        indices.push_back(base + 2);
        indices.push_back(base + 3);

        BaseObject* object = new BaseObject{ vertices, indices, mat };
        object->setPosition(position, scale, rotationAngles);
        m_BaseObjects.push_back(object);
        m_pendingToRegister.push_back(object);
        return static_cast<unsigned int>(m_BaseObjects.size() - 1);
    }

    void initObject(VkPhysicalDevice& physicalDevice, VkDevice& device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue) {
        for (auto& object : m_BaseObjects) {
            object->init(physicalDevice, device, commandPool, graphicsQueue);
        }
        // Now buffers exist ? register into chunks with MeshKey (pipelineIndex=0 for 3D)
        for (BaseObject* o : m_pendingToRegister) {
            if (o->isInitialized())
                m_chunks.add(o, MakeMeshKey(o, 0));
        }
        m_pendingToRegister.clear();
    }

    void setFrameView(const glm::vec3& cameraPos, float renderDistance) {
        m_chunks.setCulling(cameraPos, renderDistance);
    }

    void drawScene(VkPipelineLayout& pipelineLayout, VkCommandBuffer& buffer) override {
        m_chunks.forVisibleBatches([&](const MeshKey& key, const std::vector<BaseObject*>& batch) {
            for (BaseObject* obj : batch) {
                obj->draw(pipelineLayout, buffer);
            }
            });
    }

    void updateLocationObject(unsigned int pos, glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles) {
        if (pos >= m_BaseObjects.size()) return;
        BaseObject* obj = m_BaseObjects[pos];
        obj->setPosition(position, scale, rotationAngles);
        m_chunks.update(obj, MakeMeshKey(obj, 0));
    }

    void notifyMoved(BaseObject* obj) {
        if (!obj) return;
        m_chunks.update(obj, MakeMeshKey(obj, 0));
    }

    glm::vec3 getLocation(unsigned int pos) {
        if (pos < m_BaseObjects.size()) return m_BaseObjects[pos]->getPosition();
        return glm::vec3(0);
    }

    void deleteScene(VkDevice device) override {
        for (auto& object : m_BaseObjects) {
            m_chunks.remove(object);
            object->destroy(device);
            delete object;
        }
        m_BaseObjects.clear();
    }

private:
    std::vector<BaseObject*> m_BaseObjects{};
    std::vector<BaseObject*> m_pendingToRegister{};
    ChunkGrid m_chunks;
};


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\MeshScene.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\ParticleScene.h -----

#pragma once

#include <vulkan\vulkan_core.h>
#include <glm/glm.hpp>
#include <Engine/Graphics/Mesh.h>
#include <Engine/Scene/GameObjects/BaseObject.h>
#include <Engine/Scene/Scene.h>
#include <Engine/Graphics/ParticleGroup.h>

class ParticleScene : public Scene {
public:

    void addParticleGroup(physx::PxVec4* particleBuffer, int ParticleCount , std::vector<Particle> particles, glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles)
    {
        ParticleGroup* object = new ParticleGroup{ particleBuffer , ParticleCount , particles};
        object->setPosition(position, scale, rotationAngles);

        m_ParticleGroups.push_back(object);
    }

    void addParticleGroup(std::vector<Particle> particles)
    {
        ParticleGroup* object = new ParticleGroup{ nullptr , 0 , particles };

        m_ParticleGroups.push_back(object);
    }

    void drawScene(VkPipelineLayout& pipelineLayout, VkCommandBuffer& buffer) {
        for (auto& object : m_ParticleGroups) {
            object->draw(pipelineLayout, buffer);
        }
    }

    void deleteScene(VkDevice device) {
        for (auto& object : m_ParticleGroups) {
            object->destroyParticleGroup(device);
        }
    }

    ParticleGroup* getLastParticleGroup()
    {
        if (m_ParticleGroups.size())
        {
            return m_ParticleGroups[m_ParticleGroups.size() - 1];
        }
        return nullptr;
       
    }

private:
    std::vector<ParticleGroup*> m_ParticleGroups{};
};


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\ParticleScene.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\Scene.h -----

#pragma once
#include <Engine/Graphics/ShaderBase.h>
class Scene {
public:

    virtual void drawScene(VkPipelineLayout& pipelineLayout, VkCommandBuffer& buffer) = 0;
    virtual  void deleteScene(VkDevice device) = 0;
    
};


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\Scene.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\SceneModelManager.h -----

#pragma once

#include <vector>
#include <variant>
#include "MeshScene.h"
#include "ParticleScene.h"

enum class SceneModelType {
    Mesh,
    Particle
};

struct SceneObject {
    SceneModelType type;
    std::variant<BaseObject*, ParticleGroup*> object;
};

class SceneModelManager {
public:
    static SceneModelManager& getInstance() {
        static SceneModelManager instance;
        return instance;
    }

    SceneModelManager(const SceneModelManager&) = delete;
    SceneModelManager& operator=(const SceneModelManager&) = delete;

    void initScenes(VkPhysicalDevice& physicalDevice, VkDevice& device,
        const VkCommandPool& commandPool, const VkQueue& graphicsQueue) {
        m_meshScene->initObject(physicalDevice, device, commandPool, graphicsQueue);
       
    }

    BaseObject* addMeshModel(const std::vector<Vertex>& vertices,
        const std::vector<uint32_t>& indices,
        glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles, const std::shared_ptr<Material> mat = {})
    {
        unsigned int index = m_meshScene->addModel(vertices, indices, position, scale, rotationAngles, mat);
        BaseObject* obj = m_meshScene->getBaseObject(index); 
        m_sceneObjects.push_back({ SceneModelType::Mesh, obj });
        return obj;
    }

    BaseObject* addMeshRectangle(const glm::vec3& normal,
        const glm::vec3& color,
        float width, float height,
        glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles, const std::shared_ptr<Material> mat = {})
    {
        unsigned int index = m_meshScene->addRectangle(normal, color, width, height, position, scale, rotationAngles, mat);
        BaseObject* obj = m_meshScene->getBaseObject(index); 
        m_sceneObjects.push_back({ SceneModelType::Mesh, obj });
        return obj;
    }

    ParticleGroup* addParticleGroup(physx::PxVec4* particleBuffer, int ParticleCount, std::vector<Particle> particles, glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles)
    {
        m_particleScene->addParticleGroup(particleBuffer,ParticleCount,particles,position,scale,rotationAngles);
        ParticleGroup* obj = m_particleScene->getLastParticleGroup(); 
        m_sceneObjects.push_back({ SceneModelType::Particle, obj });
        return obj;
    }

    const std::vector<SceneObject>& getSceneObjects() const {
        return m_sceneObjects;
    }

    void setFrameView(const glm::vec3& cameraPos, float renderDistance) {
        if (m_meshScene) m_meshScene->setFrameView(cameraPos, renderDistance);
        // ParticleScene can stay as-is for now.
    }

    void updateObjectTransform(size_t index, glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles) {
        if (index >= m_sceneObjects.size()) return;
        const SceneObject& so = m_sceneObjects[index];
        if (so.type == SceneModelType::Mesh) {
            auto* obj = std::get<BaseObject*>(so.object);
            if (!obj) return;
            obj->setPosition(position, scale, rotationAngles);
            // NEW: make chunk membership consistent
            if (m_meshScene) m_meshScene->notifyMoved(obj);
        }
        else if (so.type == SceneModelType::Particle) {
            auto* obj = std::get<ParticleGroup*>(so.object);
            if (obj) obj->setPosition(position, scale, rotationAngles);
        }
    }

    void destroy(VkDevice device) {
        m_meshScene->deleteScene(device);
        m_particleScene->deleteScene(device);
    }

    MeshScene* getMeshScene() { return m_meshScene; }
    ParticleScene* getParticleScene() { return m_particleScene; }

private:
    SceneModelManager() {
        m_meshScene = new MeshScene();
        m_particleScene = new ParticleScene();
    }

    ~SceneModelManager() {
        delete m_meshScene;
        delete m_particleScene;
    }

    MeshScene* m_meshScene;
    ParticleScene* m_particleScene;
    std::vector<SceneObject> m_sceneObjects;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\SceneModelManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\BaseObject.h -----

#pragma once

#include <glm/glm.hpp>
#include <Engine/Graphics/Mesh.h>
#include <memory>

class BaseObject {
public:
    BaseObject(const std::vector<Vertex>& Vertexes, const std::vector<uint32_t>& indices, const std::shared_ptr<Material> mat = {}) {
        mesh = std::make_unique<Mesh>(Vertexes, indices, mat);
    }
   
    void draw(VkPipelineLayout& pipelineLayout, VkCommandBuffer& buffer) {
        mesh->draw(pipelineLayout, buffer);
    }

    void setPosition(glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles) {
        mesh->setPosition(position, scale, rotationAngles);
    }

    glm::vec3 getPosition() {
        return mesh->getPostion();
    }

    void init(VkPhysicalDevice& physicalDevice, VkDevice& device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue) {
        mesh->initialize(physicalDevice, device, commandPool, graphicsQueue);
    }

    void destroy(VkDevice device) {
        mesh->destroyMesh(device);
    }

    // --- NEW: pass-through getters for batching ---
    VkBuffer getVertexBuffer() const { return mesh->getVertexBuffer(); }
    VkBuffer getIndexBuffer()  const { return mesh->getIndexBuffer(); }
    VkDeviceSize getVBOffset() const { return mesh->getVBOffset(); }
    VkDeviceSize getIBOffset() const { return mesh->getIBOffset(); }
    uint32_t getIndexCount()   const { return mesh->getIndexCount(); }
    const std::shared_ptr<Material>& getMaterial() const { return mesh->getMaterial(); }
    bool isInitialized() const { return mesh->isInitialized(); }

    // Optional:
    Mesh* rawMesh() { return mesh.get(); }
    const Mesh* rawMesh() const { return mesh.get(); }

    void setLogicalGroupId(uint64_t id) { m_logicalGroupId = id; }
    uint64_t getLogicalGroupId() const { return m_logicalGroupId; }

protected:
    std::unique_ptr<Mesh> mesh;
    uint64_t m_logicalGroupId = 0;   // 0 = not grouped
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\BaseObject.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\Component.h -----

#pragma once

class GameObject;

class Component {
public:
    virtual ~Component() = default;

    void setParent(GameObject* parent) { m_parent = parent; }

    GameObject* getParent() const { return m_parent; }

    virtual void initialize() {}
    virtual void update() {}
    virtual void render() {}

protected:
    GameObject* m_parent = nullptr;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\Component.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\GameObject.h -----

#pragma once

#include <vector>
#include <memory>
#include <type_traits>
#include "Component.h"
#include "TransformComponent.h"
#include "ModelMeshComponent.h"
#include "PrimitiveMeshComponent.h"

class GameObject {
public:
    GameObject() {
        m_transform = addComponent<TransformComponent>();
    }

    ~GameObject() = default;

    template<typename T, typename... Args>
    T* addComponent(Args&&... args) {
        static_assert(std::is_base_of<Component, T>::value, "T must derive from Component");
        auto component = std::make_unique<T>(std::forward<Args>(args)...);
        T* rawPtr = component.get();
        rawPtr->setParent(this);
        m_components.push_back(std::move(component));
        return rawPtr;
    }

    template<typename T>
    bool hasComponent() const {
        for (const auto& comp : m_components) {
            if (dynamic_cast<T*>(comp.get()))
                return true;
        }
        return false;
    }

    void initialize() {
        for (auto& comp : m_components)
            comp->initialize();
    }

    void update() {
        for (auto& comp : m_components)
            comp->update();
    }

    void render() {
        for (auto& comp : m_components)
            comp->render();
    }

    TransformComponent* getTransform() const { return m_transform; }

private:
    std::vector<std::unique_ptr<Component>> m_components;
    TransformComponent* m_transform; 
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\GameObject.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\ModelMeshComponent.h -----

#pragma once

#include "Component.h"
#include <vector>
#include <string>
#include <iostream>
#include <memory>
#include <Engine/Graphics/Material.h>

class ModelMeshComponent : public Component {
public:
    // NEW: take an optional material (default null like your primitives)
    ModelMeshComponent(GameObject* parent,
        const std::string& modelFile,
        const std::shared_ptr<Material> mat = {},
        bool makeGlobal = false,
        bool groupByFile = true)
        : m_modelFile(modelFile)
        , m_material(mat)
        , m_makeGlobal(makeGlobal)
        , m_groupByFile(groupByFile)
    {
        setParent(parent);
        addModelToScene(modelFile);
    }

    void initialize() override { std::cout << "ModelMeshComponent initialized.\n"; }
    void update() override { std::cout << "ModelMeshComponent updated.\n"; }
    void render() override { std::cout << "ModelMeshComponent rendered.\n"; }

private:
    void addModelToScene(const std::string& modelFile);

    std::string m_modelFile;
    std::shared_ptr<Material> m_material;   // NEW
    bool m_makeGlobal = false;
    bool m_groupByFile = true;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\ModelMeshComponent.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\PrimitiveMeshComponent.h -----

#pragma once

#include "Component.h"
#include "../SceneModelManager.h"
#include <glm/glm.hpp>
#include <iostream>

enum class PrimitiveType {
    Plane,
    Cube
};

class PrimitiveMeshComponent : public Component {
public:
    PrimitiveMeshComponent(GameObject* parent, PrimitiveType type, float width = 1.f, float height = 1.f, float depth = 1.f, const std::shared_ptr<Material> mat = {}, bool makeGlobal = false)
        :m_makeGlobal(makeGlobal)
    {
        setParent(parent);
        addPrimitiveToScene(type, width, height, depth, mat);
    }

    void initialize() override {
        std::cout << "PrimitiveMeshComponent initialized." << std::endl;
    }
    void update() override {
        std::cout << "PrimitiveMeshComponent updated." << std::endl;
    }
    void render() override {
        std::cout << "PrimitiveMeshComponent rendered." << std::endl;
    }

private:
    // Updated to accept dimensions.
    void addPrimitiveToScene(PrimitiveType type, float width, float height, float depth, const std::shared_ptr<Material> mat = {});
    bool m_makeGlobal = false;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\PrimitiveMeshComponent.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\TransformComponent.h -----

#pragma once

#include "Component.h"
#include <glm/glm.hpp>
#include <iostream>

class TransformComponent : public Component {
public:
    TransformComponent()
        : position(0.0f), scale(1.0f), rotation(0.0f) {
    }

    glm::vec3 position;
    glm::vec3 scale;
    glm::vec3 rotation;

    void initialize() override {
        std::cout << "TransformComponent initialized." << std::endl;
    }

    void update() override {
        std::cout << "TransformComponent updated." << std::endl;
    }

    void render() override {
        std::cout << "TransformComponent rendered." << std::endl;
    }
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\TransformComponent.h -----

