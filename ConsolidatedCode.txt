Consolidated Code from 'C:\Users\briek\Documents\GitHub\VulkanRenderer'



----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Game.h -----

#pragma once

#include <chrono>
#include <iostream>
#include <thread>
#include <vector>
#include <iomanip>

#include <Engine/Core/WindowManager.h>
#include <Engine/Input/InputManager.h>
#include <Engine/Graphics/RendererManager.h>
#include <Engine/Physics/PhysxBase.h>
#include <Engine/Scene/SceneModelManager.h>
#include <Engine/Scene/GameSceneManager.h>

class Game {
public:
    Game();
    ~Game();

    void init();
    void run();

private:
    void initScene();

    bool m_CapFps = false;
    const int m_FPSCap = 60;
    const std::chrono::nanoseconds m_FrameDuration = std::chrono::nanoseconds(1'000'000'000 / m_FPSCap);

    WindowManager& m_WindowManager;
    RendererManager* m_Renderer;
    Camera* m_Camera;

    PhysxBase& m_Physics;
    SceneModelManager& m_SceneManager;
    GameSceneManager& m_GameScene;

    std::vector<RenderItem> m_RenderItems;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Game.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Core\Singleton.h -----

#pragma once

template <typename T>
class Singleton
{
public:
	static T& GetInstance()
	{
		static T instance{};
		return instance;
	}

	virtual ~Singleton() = default;
	Singleton(const Singleton& other) = delete;
	Singleton(Singleton&& other) = delete;
	Singleton& operator=(const Singleton& other) = delete;
	Singleton& operator=(Singleton&& other) = delete;

protected:
	Singleton() = default;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Core\Singleton.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Core\WindowManager.h -----

#pragma once
#include <GLFW/glfw3.h>
#include <Engine/Platform/PlatformWindow.h>

class WindowManager {
public:
    static WindowManager& GetInstance();

    void initWindow();

    PlatformWindow* getPlatformWindow() const;

    void handleKeyEvent(int key, int scancode, int action, int mods);
    void handleCursorPos(double xpos, double ypos);
    void handleMouseButton(int button, int action, int mods);

#ifdef _WIN32
    static void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);
    static void cursorPosCallback(GLFWwindow* window, double xpos, double ypos);
    static void mouseButtonCallback(GLFWwindow* window, int button, int action, int mods);
#endif

private:
    WindowManager();
    ~WindowManager();

    WindowManager(const WindowManager&) = delete;
    WindowManager& operator=(const WindowManager&) = delete;
    WindowManager(WindowManager&&) = delete;
    WindowManager& operator=(WindowManager&&) = delete;

    PlatformWindow* m_platformWindow = nullptr;
};


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Core\WindowManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\CommandBuffer.h -----

#pragma once
#include "vulkan\vulkan_core.h"

class CommandBuffer {
public:
	CommandBuffer() {};

	void setVkCommandBuffer( VkCommandBuffer buffer);
	VkCommandBuffer m_VkCommandBuffer;;
	void reset()const;
	void beginRecording()const;
	void endRecording()const;

	void submit(VkSubmitInfo& info) const;
private:
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\CommandBuffer.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\CommandPool.h -----

#pragma once

#include <vulkan/vulkan_core.h>
#include <Engine/Graphics/CommandBuffer.h>
#include <Engine/Graphics/Vertex.h>
#include <Engine/Graphics/QueueFamilyIndices.h>

class CommandPool
{
public:
	CommandPool() {};
	VkCommandPool m_CommandPool{ VK_NULL_HANDLE };
	
	void initialize( const QueueFamilyIndices& queue);
	void destroy();

	CommandBuffer createCommandBuffer() const;
private:
	VkDevice m_VkDevice;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\CommandPool.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\DataBuffer.h -----

#pragma once
#include <stdexcept>
#include <cstring>
#include <vulkan/vulkan_core.h>

class DataBuffer
{
public:
    DataBuffer(
        VkPhysicalDevice physicalDevice,
        VkDevice device,
        VkBufferUsageFlags usage,
        VkMemoryPropertyFlags properties,
        VkDeviceSize size
    );

    ~DataBuffer() = default;

    // Back-compat names, now zero-cost wrappers over persistent mapping
    void upload(VkDeviceSize size, void* data);
    void uploadRaw(VkDeviceSize size, void* data, VkDeviceSize dstOffset);
    void map(VkDeviceSize size, void* data);      // wrapper over upload()
    void remap(VkDeviceSize size, void* data);    // wrapper over upload()

    void destroy(const VkDevice& device);

    void bindAsVertexBuffer(VkCommandBuffer commandBuffer);
    void bindAsIndexBuffer(VkCommandBuffer commandBuffer);

    VkBuffer getVkBuffer();
    void* getUniformBuffer();                     // returns persistent mapped ptr

    VkDeviceSize getSizeInBytes();
    VkDeviceMemory getBufferMemory() { return m_VkBufferMemory; }

    // NOTE: still sync-submits a tiny one-time CB with a fence.
    // In a perf pass you’d batch this at frame level.
    void copyBuffer(VkBuffer srcBuffer, const VkCommandPool& commandPool,
        const VkDevice& device, VkDeviceSize size, const VkQueue& graphicsQueue);

    static uint32_t findMemoryType(VkPhysicalDevice physicalDevice,
        uint32_t typeFilter, VkMemoryPropertyFlags properties);

private:
    // Helpers
    bool isHostVisible()  const { return (m_Properties & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0; }
    bool isHostCoherent() const { return (m_Properties & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) != 0; }

    VkDevice m_VkDevice = VK_NULL_HANDLE;
    VkBuffer m_VkBuffer = VK_NULL_HANDLE;
    VkDeviceMemory m_VkBufferMemory = VK_NULL_HANDLE;
    VkDeviceSize m_Size = 0;

    // Persistent mapping
    VkMemoryPropertyFlags m_Properties{};
    void* m_Mapped = nullptr;
    VkDeviceSize m_NonCoherentAtomSize = 0;

    // Back-compat alias (some old code may still read this)
    void* m_UniformBufferMapped = nullptr;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\DataBuffer.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\DescriptorPool.h -----

#pragma once

#include <vector>
#include <memory>
#include <Engine/Graphics/DataBuffer.h>

class DescriptorPool
{
public:
	DescriptorPool() {};
	DescriptorPool(const VkDevice& device, VkDeviceSize size, size_t count);
	void Initialize(const VkDevice& device);

	void Destroy(const VkDevice& device);

	const VkDescriptorSetLayout& getDescriptorSetLayout()
	{
		return m_DescriptorSetLayout;
	}

	~DescriptorPool() ;
	void createDescriptorSets(const std::vector<VkBuffer>& buffers, const std::vector<std::vector<VkDescriptorImageInfo>>& images);

	void bindDescriptorSet(VkCommandBuffer buffer, VkPipelineLayout layout, size_t index);

private:
	VkDevice m_Device;
	VkDeviceSize m_Size;
	VkDescriptorPool m_DescriptorPool;
	std::vector<VkDescriptorSet> m_DescriptorSets;
	size_t m_Count;
	VkDescriptorSetLayout m_DescriptorSetLayout;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\DescriptorPool.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ImageDataBuffer.h -----


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ImageDataBuffer.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Material.h -----

#pragma once

#include <memory>
#include <string>
#include <Engine/Graphics/Texture.h>
#include <Engine/Graphics/TextureManager.h> // <-- Include this!
#include <atomic>

class Material {
public:
    Material(const std::string& albedoMapFileName = "",
        const std::string& normalMapFileName = "",
        const std::string& metalnessMapFileName = "",
        const std::string& roughnessMapFileName = "",
        const std::string& heightMapFileName = "");

    std::shared_ptr<Texture> getAlbedoMapTexture() const { return m_AlbedoMapTexture; }
    std::shared_ptr<Texture> getNormalMapTexture()  const { return m_NormalMapTexture; }
    std::shared_ptr<Texture> getMetalnessMapTexture()  const { return m_MetalnessMapTexture; }
    std::shared_ptr<Texture> getRoughnessMapTexture()  const { return m_RoughnessMapTexture; }
    std::shared_ptr<Texture> getHeightMapTexture()  const { return m_HeightMapTexture; }

    uint32_t getAlbedoMapID() const { return m_AlbedoMapTexture ? m_AlbedoMapTexture->getID() : UINT32_MAX; }
    uint32_t getNormalMapID() const { return m_NormalMapTexture ? m_NormalMapTexture->getID() : UINT32_MAX; }
    uint32_t getMetalnessMapID() const { return m_MetalnessMapTexture ? m_MetalnessMapTexture->getID() : UINT32_MAX; ; }
    uint32_t getRoughnessMapID() const { return m_RoughnessMapTexture ? m_RoughnessMapTexture->getID() : UINT32_MAX; ; }
    uint32_t getHeightMapID() const { return m_HeightMapTexture ? m_HeightMapTexture->getID() : UINT32_MAX; ; }

    std::vector<std::shared_ptr<Texture>> getAllTextures() const;

private:
    std::shared_ptr<Texture> m_AlbedoMapTexture;
    std::shared_ptr<Texture> m_NormalMapTexture;
    std::shared_ptr<Texture> m_MetalnessMapTexture;
    std::shared_ptr<Texture> m_RoughnessMapTexture;
    std::shared_ptr<Texture> m_HeightMapTexture;

};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Material.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\MaterialManager.h -----

#pragma once

#include <unordered_map>
#include <memory>
#include <string>
#include <vector>
#include <Engine/Graphics/Material.h>
#include <Engine/Graphics/Texture.h>
#include <Engine/Core/Singleton.h>

class MaterialManager : public Singleton<MaterialManager> {
public:
    // Get or create material by filepath (uses cache)
    std::shared_ptr<Material> getOrCreateMaterial(const std::string& filepath);

    // Standard material getter/setter
    void setStandardMaterial(const std::shared_ptr<Material>& material) { m_standardMaterial = material; }
    std::shared_ptr<Material> getStandardMaterial() const { return m_standardMaterial; }

    // Active materials getters/setters
    std::vector<std::shared_ptr<Material>>& getActiveMaterials() { return m_activeMaterials; }
    const std::vector<std::shared_ptr<Material>>& getActiveMaterials() const { return m_activeMaterials; }
    void setActiveMaterials(const std::vector<std::shared_ptr<Material>>& mats);

    // Add/remove material to/from active list (prevents duplicates)
    void addActiveMaterial(const std::shared_ptr<Material>& material);
    void removeActiveMaterial(const std::shared_ptr<Material>& material);

    // Find by ID or index (utility)
    std::shared_ptr<Material> getMaterialByID(uint32_t materialID) const;
    std::shared_ptr<Material> getMaterialByIndex(size_t idx) const;

    // Get number of active materials/textures
    size_t getNumActiveMaterials() const { return m_activeMaterials.size(); }

    // Clear active material list
    void clearActiveMaterials();

    // (Optional) Get all cached materials (not just active)
    std::vector<std::shared_ptr<Material>> getAllCachedMaterials() const;

    bool isTextureListDirty() const { return m_textureListDirty; }
    void clearTextureListDirty() { m_textureListDirty = false; }

private:
    friend class Singleton<MaterialManager>;
    MaterialManager();

    std::unordered_map<std::string, std::shared_ptr<Material>> m_materialCache;
    std::vector<std::shared_ptr<Material>> m_activeMaterials;
    std::shared_ptr<Material> m_standardMaterial;

    bool m_textureListDirty = true;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\MaterialManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Mesh.h -----

#pragma once

#include <vulkan\vulkan_core.h>
#include <Engine/Graphics/Vertex.h>
#include <glm/glm.hpp>
#include <Engine/Graphics/DataBuffer.h>
#include <Engine/Graphics/MeshData.h>
#include <Engine/Graphics/MaterialManager.h>
#include <memory>
class Mesh {
public:
	Mesh(const std::vector<Vertex>& Vertexes, const std::vector<uint16_t>& indices, const std::shared_ptr<Material> mat = {});
	void initialize(VkPhysicalDevice physicalDevice, VkDevice device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue);
	void destroyMesh(const VkDevice& device);

	void setPosition(glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles);
	glm::vec3 getPostion() { return m_Position; }
	void addVertex(glm::vec3 pos, glm::vec3 color, glm::vec3 normal);
	void addTriangle(uint16_t i1, uint16_t i2, uint16_t i3, uint16_t offset = 0);

	void draw(VkPipelineLayout pipelineLayout, VkCommandBuffer commandBuffer);
private:
	std::vector<Vertex> m_Vertices;
	std::vector<uint16_t> m_Indices;
	std::unique_ptr<DataBuffer> m_VertexBuffer;
	std::unique_ptr<DataBuffer> m_IndexBuffer;

	MeshData m_VertexConstant;

	glm::vec3 m_Position = {};
	std::shared_ptr<Material> m_Material;
	void CreateVertexBuffer(VkPhysicalDevice physicalDevice, VkDevice device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue);
	void CreateIndexBuffer(VkPhysicalDevice physicalDevice, VkDevice device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue);
}; 

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Mesh.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\MeshData.h -----

#pragma once
#include <glm/glm.hpp>

struct MeshData {
    glm::mat4 model;
    uint32_t AlbedoID;
    uint32_t NormalMapID;
    uint32_t MetalnessID;
    uint32_t RoughnessID;
    uint32_t HeightMapID;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\MeshData.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Particle.h -----

#pragma once
#include <glm/glm.hpp>
#include <vulkan/vulkan_core.h>
#include <vector>

struct Particle {
	glm::vec4 pos;

	Particle(glm::vec4 p) { pos = p; }
	Particle() { pos = {}; }

	static VkVertexInputBindingDescription getBindingDescription() {
		VkVertexInputBindingDescription bindingDescription{};
		bindingDescription.binding = 0;
		bindingDescription.stride = sizeof(Particle);
		bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
		return bindingDescription;
	}

	static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions() {
		std::vector<VkVertexInputAttributeDescription> attributeDescriptions(1);

		attributeDescriptions[0].binding = 0;
		attributeDescriptions[0].location = 0;
		attributeDescriptions[0].format = VK_FORMAT_R32G32B32A32_SFLOAT;
		attributeDescriptions[0].offset = offsetof(Particle, pos);

		return attributeDescriptions;
	}

};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Particle.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ParticleGroup.h -----

#pragma once

#include <vulkan\vulkan_core.h>
#include <glm/glm.hpp>
#include <Engine/Graphics/DataBuffer.h>

#include <Engine/Graphics/vulkanVars.h>
#include <Engine/Graphics/MeshData.h>
#include <Engine/Graphics/Particle.h>
#include <memory>
#include <array>

#include <PxParticleBuffer.h>

#include <Engine/Graphics/ShaderBase.h>

class ParticleGroup {
public:
	ParticleGroup(physx::PxVec4* particleBuffer, int ParticleCount, const std::vector<Particle>& particles);
	void initialize(VkPhysicalDevice physicalDevice, VkDevice device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue);
	
	void setPosition(glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles);

	void destroyParticleGroup(const VkDevice& device);

	void draw(VkPipelineLayout pipelineLayout, VkCommandBuffer commandBuffer);
private:

	std::vector<Particle> m_Particles;
	std::array<std::unique_ptr<DataBuffer>, MAX_FRAMES_IN_FLIGHT> m_ParticleBuffers;

	MeshData m_VertexConstant = {  };
	physx::PxVec4* m_pParticleBuffer;
	int m_ParticleCount;
	void CreateParticleBuffer(VkPhysicalDevice physicalDevice, VkDevice device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue);

	void update();
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ParticleGroup.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Pipeline.h -----

#pragma once
#include <vector>
#include <memory>
#include <vulkan\vulkan_core.h>

#include <Engine/Graphics/ShaderBase.h>
#include <Engine/Graphics/CommandBuffer.h>
#include <Engine/Graphics/CommandPool.h>
#include <Engine/Scene/Scene.h>
#include <Engine/Graphics/UniformBufferObject.h>


struct PipelineConfig {
	VkRenderPass renderPass = VK_NULL_HANDLE;           // which render pass to build for
	VkPrimitiveTopology topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;

	// Depth state
	bool enableDepthTest = true;
	bool enableDepthWrite = true;

	// Vertex input: if false -> fullscreen/no-VB style
	bool useVertexInput = true;

	// Push constants: keep off for post
	bool usePushConstants = true;

	// If provided, Pipeline will use these instead of ShaderBase’s layout & sets.
	VkDescriptorSetLayout externalSetLayout = VK_NULL_HANDLE;
	const std::vector<VkDescriptorSet>* externalSets = nullptr;

	// If true, Record() draws a fullscreen triangle (3 verts) instead of Scene.
	bool fullscreenTriangle = false;
};

class Pipeline
{
public:
	Pipeline();
	~Pipeline();
	void Destroy(const VkDevice& vkDevice);
	void Initialize(const std::string& vertexShaderPath,
		const std::string& fragmentShaderPath,
		const VkVertexInputBindingDescription vkVertexInputBindingDesc,
		std::vector<VkVertexInputAttributeDescription> vkVertexInputAttributeDesc,
		const PipelineConfig& config);
	void Initialize(const std::string& vertexShaderPath, const std::string& fragmentShaderPath, const VkVertexInputBindingDescription vkVertexInputBindingDesc, std::vector<VkVertexInputAttributeDescription> vkVertexInputAttributeDesc, VkPrimitiveTopology topology);
	void Record(uint32_t imageIndex, VkRenderPass renderPass, const std::vector<VkFramebuffer>& swapChainFramebuffers, VkExtent2D swapChainExtent, Scene& scene);

	void setUbo(const UniformBufferObject& ubo) { m_Ubo = ubo; }
	void updateDescriptorSets();
	static VkFormat findDepthFormat(VkPhysicalDevice& vkPhysicalDevice, VkDevice& vkDevice);
	VkImage getDepthImage() { return m_DepthImage; };
	VkDeviceMemory getDepthImageMemory() { return m_DepthImageMemory; };
	VkImageView getDepthImageView() { return m_DepthImageView; };

private:
	void drawScene(uint32_t imageIndex, VkRenderPass renderPass, const std::vector<VkFramebuffer>& swapChainFramebuffers, VkExtent2D swapChainExtent, Scene& scene);

	void CreatePipeline(VkDevice device, VkRenderPass renderPass, VkPrimitiveTopology topology);

	VkPipeline m_Pipeline3d;
	std::unique_ptr<ShaderBase> m_Shader;
	PipelineConfig m_Config{};                  // NEW
	bool m_UseExternalDescriptors = false;      // NEW
	VkPipelineVertexInputStateCreateInfo m_EmptyVI{}; // NEW
	const VkPipelineVertexInputStateCreateInfo* pickVI(); // NEW
	UniformBufferObject m_Ubo{};

	VkPipelineLayout m_PipelineLayout;
	void updateUniformBuffer(uint32_t currentImage, VkExtent2D swapChainExtent);

	VkPushConstantRange createPushConstantRange();

	void createImage(VkPhysicalDevice& vkPhysicalDevice, VkDevice& vkDevice,uint32_t width, uint32_t height, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage& image, VkDeviceMemory& imageMemory);
	
	static VkFormat findSupportedFormat(VkPhysicalDevice& vkPhysicalDevice, VkDevice& vkDevice, const std::vector<VkFormat>& candidates, VkImageTiling tiling, VkFormatFeatureFlags features);
	void createDepthResources(VkPhysicalDevice& vkPhysicalDevice, VkDevice& vkDevice, VkExtent2D swapChainExtent);

	bool hasStencilComponent(VkFormat format);
	VkImageView createImageView(VkDevice& vkDevice, VkImage image, VkFormat format, VkImageAspectFlags aspectFlags);

	VkImage m_DepthImage;
	VkDeviceMemory m_DepthImageMemory;
	VkImageView m_DepthImageView;
};


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Pipeline.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\QueueFamilyIndices.h -----

#pragma once
#include <optional>

struct QueueFamilyIndices {
	std::optional<uint32_t> graphicsFamily;
	std::optional<uint32_t> presentFamily;

	bool isComplete() {
		return graphicsFamily.has_value() && presentFamily.has_value();
	}
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\QueueFamilyIndices.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\RendererManager.h -----

#pragma once

#include <vulkan/vulkan.h>
#include <GLFW/glfw3.h>
#include <Engine/Scene/Scene.h>
#include <Engine/Math/Camera.h>
#include <Engine/Graphics/Pipeline.h>
#include <Engine/Graphics/vulkanVars.h>
#include <Engine/Graphics/SwapChainSupportDetails.h>


#ifdef NDEBUG
const bool enableValidationLayers = false;
#else
const bool enableValidationLayers = true;
#endif

const std::vector<const char*> validationLayers = {
    "VK_LAYER_KHRONOS_validation"
};

const std::vector<const char*> deviceExtensions = {
    VK_KHR_SWAPCHAIN_EXTENSION_NAME
};

struct RenderStage {
    std::string name; // Optional, for debugging
    VkRenderPass renderPass;
    std::vector<VkFramebuffer>* framebuffers;
    std::vector<Pipeline*> pipelines;
    bool hasDepth = false; // NEW
};

struct OffscreenTarget {
    VkImage image = VK_NULL_HANDLE;
    VkDeviceMemory memory = VK_NULL_HANDLE;
    VkImageView view = VK_NULL_HANDLE;
};

struct DepthTarget {
    VkImage image = VK_NULL_HANDLE;
    VkDeviceMemory memory = VK_NULL_HANDLE;
    VkImageView view = VK_NULL_HANDLE;
};

struct RenderItem {
    Scene* scene;
    int pipelineIndex;
};

class RendererManager {
public:
    RendererManager();
    ~RendererManager();

    void Initialize();

   
    void RenderFrame(const std::vector<RenderItem>& renderItems, Camera& camera);

    void Cleanup();

private:
    Pipeline m_Pipeline3d;
    Pipeline m_PipelineParticles;
    Pipeline m_PipelinePostProcess;

    std::vector<RenderStage> m_RenderStages;

    VkRenderPass m_RenderPassOffscreen = VK_NULL_HANDLE; // scene (color+depth), final = COLOR_ATTACHMENT_OPTIMAL
    VkRenderPass m_RenderPassPresent = VK_NULL_HANDLE;  // post (color only), final = PRESENT_SRC_KHR
    std::vector<OffscreenTarget> m_OffscreenTargets;
    std::vector<VkFramebuffer>   m_OffscreenFramebuffers;
    VkDescriptorSetLayout m_PostSetLayout = VK_NULL_HANDLE;
    VkDescriptorPool      m_PostDescPool = VK_NULL_HANDLE;
    std::vector<VkDescriptorSet> m_PostDescSets;
    VkSampler             m_PostSampler = VK_NULL_HANDLE;
    VkSampler m_PostDepthSampler; // add a member
    std::vector<DepthTarget> m_OffscreenDepthTargets;

    void createRenderPasses();
    void createOffscreenTargets();
    void createFramebuffersOffscreen();
    void createFramebuffersPresent();
    void createPostDescriptors();

    void writePostDescriptors();

    void createOffscreenDepthTargets();

    VkSurfaceKHR surface;
    VkInstance instance;
    VkQueue presentQueue;
    VkSwapchainKHR swapChain;
    std::vector<VkImage> swapChainImages;
    VkFormat swapChainImageFormat;
    std::vector<VkImageView> swapChainImageViews;

    std::vector<VkFramebuffer> swapChainFramebuffers;
    std::array<VkSemaphore, MAX_FRAMES_IN_FLIGHT> imageAvailableSemaphores;
    std::array<VkSemaphore, MAX_FRAMES_IN_FLIGHT> renderFinishedSemaphores;
    std::array<VkFence, MAX_FRAMES_IN_FLIGHT> inFlightFences;

    std::vector<VkFence> imagesInFlight;

    void createInstance();
    bool checkValidationLayerSupport();
    std::vector<const char*> getRequiredExtensions();
    void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT& createInfo);

    void setupDebugMessenger();
    VkDebugUtilsMessengerEXT debugMessenger;

    void createSurface();

    void pickPhysicalDevice();
    bool isDeviceSuitable(VkPhysicalDevice device);
    bool checkDeviceExtensionSupport(VkPhysicalDevice device);
    void createLogicalDevice();

    void createSwapChain();
    SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device);
    VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats);
    VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR>& availablePresentModes);
    VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities);
    void createImageViews();


    void createRenderPass();

    void initPipeLines();
    void createFrameBuffers();

    void createSyncObjects(size_t currentFrame = 0);
    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device);


    static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData) {
        std::cerr << "validation layer: " << pCallbackData->pMessage << std::endl;
        return VK_FALSE;
    }
    VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger);
    void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator);

    void setupStages();
    // Offscreen render target
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\RendererManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ShaderBase.h -----

#pragma once
#ifndef SHADERBASE_H
#define SHADERBASE_H

#include <vulkan/vulkan.h>
#include <Engine/Graphics/Vertex.h>
#include <vector>
#include <string>
#include <memory>
#include <array>
#include <Engine/Graphics/DataBuffer.h>
#include <Engine/Graphics/DescriptorPool.h>
#include <Engine/Graphics/UniformBufferObject.h>

#include <memory>
#include <Engine/Graphics/Texture.h>

class ShaderBase {
public:
    ShaderBase() {};
    ShaderBase( const std::string& vertexShaderPath, const std::string& fragmentShaderPath);
    ~ShaderBase();

    void Destroy(const VkDevice& vkDevice);

    void initialize(const VkPhysicalDevice& vkPhysicalDevice, const VkDevice& vkDevice, const VkVertexInputBindingDescription& vkVertexInputBindingDesc, std::vector<VkVertexInputAttributeDescription>& vkVertexInputAttributeDesc);

    void createDescriptorSetLayout(const VkDevice& vkDevice);
    const VkDescriptorSetLayout& getDescriptorSetLayout()
    {
        return m_DescriptorSetLayout;
    }
    void bindDescriptorSet(VkCommandBuffer commandBuffer, VkPipelineLayout pipelineLayout, size_t index);

    void updateUniformBuffer(uint32_t currentImage, UniformBufferObject& ubo);
    void updateDescriptorSet();
    VkPipelineShaderStageCreateInfo getVertexShaderStageInfo() ;
    VkPipelineShaderStageCreateInfo getFragmentShaderStageInfo() ;
    VkPipelineVertexInputStateCreateInfo& getVertexInputStateInfo() ;
    VkPipelineInputAssemblyStateCreateInfo& getInputAssemblyStateInfo(VkPrimitiveTopology topology) ;

private:
    VkDevice device_{};
    std::vector<char> vertexShaderCode_{};
    std::vector<char> fragmentShaderCode_{};

    VkVertexInputBindingDescription m_VkVertexInputBindingDesc{};
    VkPipelineInputAssemblyStateCreateInfo m_VkPipelineInputAssemblyStateCreateInfo{};
    std::vector<VkVertexInputAttributeDescription> m_VkVertexInputAttributeDesc{};
       
    VkShaderModule vertexShaderModule_{};
    VkShaderModule fragmentShaderModule_{};

    VkPipelineVertexInputStateCreateInfo m_VertexInputStateInfo{};

    VkDescriptorSetLayout m_DescriptorSetLayout{};
    std::vector<std::unique_ptr<DataBuffer>> m_UBOBuffers{};

    UniformBufferObject m_UBOSrc{};
    DescriptorPool m_DescriptorPool{};


    std::vector<char> readFile(const std::string& filename);
    VkShaderModule createShaderModule(const std::vector<char>& code);

    //test
    std::shared_ptr<Texture> m_Tex;
};

#endif

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\ShaderBase.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\SwapChainSupportDetails.h -----

#pragma once
#include <vulkan/vulkan_core.h>
#include <vector>


struct SwapChainSupportDetails {
	VkSurfaceCapabilitiesKHR capabilities;
	std::vector<VkSurfaceFormatKHR> formats;
	std::vector<VkPresentModeKHR> presentModes;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\SwapChainSupportDetails.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Texture.h -----

#pragma once

#include <vulkan/vulkan.h>
#include <string>
#include <atomic>

namespace {
    const std::string kErrorTexturePath = "Resources/Textures/errorTexture.jpg";
}

class Texture {
    friend class TextureManager;
public:
   
    ~Texture();

    VkImageView getImageView() const { return m_ImageView; }
    VkSampler getSampler() const { return m_Sampler; }
    VkDescriptorImageInfo getDescriptorInfo() const;

    uint32_t getID();
private:
    Texture(const std::string& filename);

    void createTextureImage(const std::string& filename);
    void createTextureImageView();
    void createTextureSampler();
    void transitionImageLayout(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout);
    void copyBufferToImage(VkBuffer buffer, VkImage image, uint32_t width, uint32_t height);

    VkImage m_Image = VK_NULL_HANDLE;
    VkDeviceMemory m_ImageMemory = VK_NULL_HANDLE;
    VkImageView m_ImageView = VK_NULL_HANDLE;
    VkSampler m_Sampler = VK_NULL_HANDLE;
    uint32_t m_Width = 0, m_Height = 0;
    uint32_t m_ID = -1;

    static std::atomic<uint32_t> s_NextID;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Texture.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\TextureManager.h -----

#pragma once

#include <unordered_map>
#include <memory>
#include <string>
#include <vector>
#include <Engine/Graphics/Texture.h>
#include <Engine/Core/Singleton.h>

class TextureManager : public Singleton<TextureManager> {
public:
    // Get or create texture by filepath (uses cache)
    std::shared_ptr<Texture> getOrCreateTexture(const std::string& filepath);

    // Standard texture getter/setter (e.g. a default white or error texture)
    void setStandardTexture(const std::shared_ptr<Texture>& texture) { m_standardTexture = texture; }
    std::shared_ptr<Texture> getStandardTexture() const { return m_standardTexture; }

    // Active textures getters/setters
    std::vector<std::shared_ptr<Texture>>& getActiveTextures() { return m_activeTextures; }
    const std::vector<std::shared_ptr<Texture>>& getActiveTextures() const { return m_activeTextures; }
    void setActiveTextures(const std::vector<std::shared_ptr<Texture>>& textures);

    // Add/remove texture to/from active list (prevents duplicates)
    void addActiveTexture(const std::shared_ptr<Texture>& texture);
    void removeActiveTexture(const std::shared_ptr<Texture>& texture);

    // Find by ID or index
    std::shared_ptr<Texture> getTextureByID(uint32_t textureID) const;
    std::shared_ptr<Texture> getTextureByIndex(size_t idx) const;

    // Get number of active textures
    size_t getNumActiveTextures() const { return m_activeTextures.size(); }

    // Clear active texture list
    void clearActiveTextures();

    // (Optional) Get all cached textures (not just active)
    std::vector<std::shared_ptr<Texture>> getAllCachedTextures() const;

    bool isTextureListDirty() const { return m_textureListDirty; }
    void clearTextureListDirty() { m_textureListDirty = false; }

private:
    friend class Singleton<TextureManager>;
    TextureManager();

    std::unordered_map<std::string, std::shared_ptr<Texture>> m_textureCache;
    std::vector<std::shared_ptr<Texture>> m_activeTextures;
    std::shared_ptr<Texture> m_standardTexture;

    bool m_textureListDirty = true;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\TextureManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\UniformBufferObject.h -----

#pragma once
#include <glm/glm.hpp>

struct UniformBufferObject {
	glm::mat4 proj;
	glm::mat4 view;
	glm::vec3 cameraPos;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\UniformBufferObject.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Vertex.h -----

#pragma once
#include <glm/glm.hpp>
#include <vulkan/vulkan_core.h>
#include <vector>

struct Vertex
{
	glm::vec3 pos;
	glm::vec3 normal;
	glm::vec3 color;
	glm::vec2 texCoord;

	Vertex(glm::vec3 pos, glm::vec3 normal, glm::vec3 color, glm::vec2 texCoord)
		:pos(pos), normal(normal), color(color), texCoord(texCoord)
	{
	}
	Vertex()
	{
		pos = {};
		normal = {};
		color = {};
	}

	static VkVertexInputBindingDescription getBindingDescription() {
		VkVertexInputBindingDescription bindingDescription{};
		bindingDescription.binding = 0;
		bindingDescription.stride = sizeof(Vertex);
		bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
		return bindingDescription;
	}

	static std::vector<VkVertexInputAttributeDescription> getAttributeDescriptions() {
		std::vector<VkVertexInputAttributeDescription> attributeDescriptions(4);

		attributeDescriptions[0].binding = 0;
		attributeDescriptions[0].location = 0;
		attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
		attributeDescriptions[0].offset = offsetof(Vertex, pos);

		attributeDescriptions[1].binding = 0;
		attributeDescriptions[1].location = 1;
		attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
		attributeDescriptions[1].offset = offsetof(Vertex, normal);

		attributeDescriptions[2].binding = 0;
		attributeDescriptions[2].location = 2;
		attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
		attributeDescriptions[2].offset = offsetof(Vertex, color);

		attributeDescriptions[3].binding = 0;
		attributeDescriptions[3].location = 3;
		attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
		attributeDescriptions[3].offset = offsetof(Vertex, texCoord);

		return attributeDescriptions;
	}
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\Vertex.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\vulkanVars.h -----

#pragma once

#include <Engine/Core/Singleton.h>
#include <Engine/Graphics/CommandBuffer.h>
#include <Engine/Graphics/CommandPool.h>

const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;
const int MAX_FRAMES_IN_FLIGHT = 3;
const int MAX_TEXTURES = 32;

class vulkanVars : public Singleton<vulkanVars> {
public:
	CommandPool commandPoolModelPipeline{};
	CommandPool commandPoolParticlesPipeline{};
	VkDevice device = VK_NULL_HANDLE;
	VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
	VkRenderPass renderPass = VK_NULL_HANDLE;
	VkQueue graphicsQueue = VK_NULL_HANDLE;
	VkExtent2D swapChainExtent;
	std::vector<CommandBuffer> commandBuffers; 
	size_t currentFrame = 0;
};



----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Graphics\vulkanVars.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Input\InputManager.h -----

#pragma once
#include <GLFW/glfw3.h>
#include <vector>
#include <Engine/Math/Camera.h>

class InputManager {
public:
    static InputManager& GetInstance();

    void Initialize(GLFWwindow* window);

    bool IsKeyDown(int key) const;
    bool IsMouseButtonDown(int button) const;
    double GetMouseX() const;
    double GetMouseY() const;

    void Update();

    void HandleCameraInputs(Camera* camera, float deltaTime);
private:
    InputManager();
    ~InputManager();

    InputManager(const InputManager&) = delete;
    InputManager& operator=(const InputManager&) = delete;
    InputManager(InputManager&&) = delete;
    InputManager& operator=(InputManager&&) = delete;

    std::vector<int> keysDown;
    std::vector<int> mouseButtonsDown;
    double mouseX;
    double mouseY;

    glm::vec2 m_LastMousePos;

    static void KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);
    static void MouseButtonCallback(GLFWwindow* window, int button, int action, int mods);
    static void CursorPosCallback(GLFWwindow* window, double xpos, double ypos);
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Input\InputManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Math\Camera.h -----

#pragma once
#include <cassert>
#include <iostream>

#include <glm/vec3.hpp> 
#include <glm/vec4.hpp> 
#include <glm/mat4x4.hpp> 
#include <glm/ext/matrix_transform.hpp> 
#include <glm/ext/matrix_clip_space.hpp> 
#include <glm/ext/scalar_constants.hpp>

struct Camera
{
	Camera() = default;

	Camera(const glm::vec3& _origin, float _fovAngle, float _aspectRatio);


	glm::vec3 origin{};
	float fovAngle{ 90.f };
	float fov{ glm::radians(fovAngle)};
	float aspectRatio{1.f};

	float nearPlane{ 0.1f };
	float farPlane{ 100.f };

	glm::vec3 forward{ 0.f,0.f,1.f };
	glm::vec3 up{ 0.f,1.f,0.f };
	glm::vec3 right{ 1.f,0.f,0.f };

	float totalPitch{ 0.f};
	float totalYaw{};

	glm::mat4 invViewMatrix{};
	glm::mat4 viewMatrix{};

	glm::mat4 projectionMatrix{};

	void Initialize(float _fovAngle = 90.f, glm::vec3 _origin = { 0.f,0.f,0.f }, float _aspectRatio = 1.f);

	void CalculateViewMatrix();
	void CalculateProjectionMatrix();

	glm::mat4 CalculateCameraToWorld();
	void printValuesCamera();
	
	void update();

	void rotate(glm::vec2 offset);
	void translateForward(float posChange);
	void translateRight(float posChange);

	void SetFov(const float fovAngleNew);
	void SetAspectRatio(const float aspect);

	glm::mat4 CreateRotationX(float pitch) {
		return glm::rotate(glm::mat4(1.0f), pitch, glm::vec3(1.0f, 0.0f, 0.0f));
	}

	glm::mat4 CreateRotationY(float yaw) {
		return glm::rotate(glm::mat4(1.0f), yaw, glm::vec3(0.0f, 1.0f, 0.0f));
	}

	glm::mat4 CreateRotationZ(float roll) {
		return glm::rotate(glm::mat4(1.0f), roll, glm::vec3(0.0f, 0.0f, 1.0f));
	}

};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Math\Camera.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\ObjUtils\ObjUtils.h -----

#pragma once

#include <Engine/Graphics/Vertex.h>
#include <Engine/Graphics/Particle.h>
#include <cstddef>
#include <vector>
#include <fstream>
#include <optional>
#include <array>
#include <glm/glm.hpp>

static bool ParseOBJ(const std::string& filename, std::vector<Vertex>& vertices, std::vector<uint16_t>& indices,glm::vec3 color ,bool flipAxisAndWinding = true)
{
	std::ifstream file(filename);
	if (!file)
		return false;

	std::vector<glm::vec3> positions{};
	std::vector<glm::vec3> normals{};
	std::vector<glm::vec2> UVs{};

	vertices.clear();
	indices.clear();

	std::string sCommand;
	while (!file.eof())
	{
		file >> sCommand;

		if (sCommand == "#")
		{
			// Ignore Comment
		}
		else if (sCommand == "v")
		{

			float x, y, z;
			file >> x >> y >> z;

			positions.emplace_back(x, y, z);
		}
		else if (sCommand == "vt")
		{
			// Vertex TexCoord
			float u, v;
			file >> u >> v;
			UVs.emplace_back(u, 1 - v);
		}
		else if (sCommand == "vn")
		{
			// Vertex Normal
			float x, y, z;
			file >> x >> y >> z;

			normals.emplace_back(x, y, z);
		}
		else if (sCommand == "f")
		{
			Vertex vertex{};
			size_t iPosition, iTexCoord, iNormal;

			uint16_t tempIndices[3];
			for (size_t iFace = 0; iFace < 3; iFace++)
			{
				file >> iPosition;
	
				vertex.pos = positions[iPosition - 1];

				if ('/' == file.peek())
				{
					file.ignore();

					if ('/' != file.peek())
					{
						file >> iTexCoord;
					}

					if ('/' == file.peek())
					{
						file.ignore();

						file >> iNormal;
						vertex.normal = normals[iNormal - 1];
					}
				}

				vertex.color = color;
				vertices.push_back(vertex);
				tempIndices[iFace] = uint16_t(vertices.size()) - 1;
			}

			indices.push_back(tempIndices[0]);
			if (flipAxisAndWinding)
			{
				indices.push_back(tempIndices[2]);
				indices.push_back(tempIndices[1]);
			}
			else
			{
				indices.push_back(tempIndices[1]);
				indices.push_back(tempIndices[2]);
			}
		}
		file.ignore(1000, '\n');
	}
}

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\ObjUtils\ObjUtils.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Physics\PhysicsManager.h -----

#pragma once
#include <PxPhysicsAPI.h>
#include "PhysxBase.h"
using namespace physx;

class PhysicsManager {
public:
    static PhysicsManager& GetInstance() {
        static PhysicsManager instance;
        return instance;
    }

    void Initialize();

    void StepPhysics(float deltaTime);

    void Cleanup();

private:
    PhysicsManager() = default;
    ~PhysicsManager() = default;
    PhysicsManager(const PhysicsManager&) = delete;
    PhysicsManager& operator=(const PhysicsManager&) = delete;

};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Physics\PhysicsManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Physics\PhysxBase.h -----

#pragma once

#include <vector>
#include <PxPhysicsAPI.h>
#include <extensions/PxParticleExt.h>
#include <Engine/Graphics/Particle.h>
#include <Engine/Core/Singleton.h>
#include <Engine/Graphics/DataBuffer.h>


using namespace physx;
using namespace ExtGpu;

// Forward declarations
class PxCudaContextManager;

class PhysxBase : public Singleton<PhysxBase>
{
public:
    PhysxBase();
    ~PhysxBase();

    void initPhysics(bool useLargeFluid);
    void stepPhysics(bool interactive, float deltaTime);
    void cleanupPhysics(bool interactive);
    float getRightWallLocation();
    std::vector<Particle>& getParticles();

    PxPBDParticleSystem* getParticleSystem();
    PxParticleAndDiffuseBuffer* getParticleBuffer();

    // Wall movement controls
    bool wallMoveLeft = false;
    bool wallMoveRight = false;

private:
    void initObstacles();
    void initScene();
    void initParticles(PxU32 numX, PxU32 numY, PxU32 numZ, const PxVec3& position, PxReal particleSpacing, PxReal fluidDensity, PxU32 maxDiffuseParticles);
    void getParticlesInternal();

    // PhysX SDK objects
    physx::PxFoundation* mFoundation = nullptr;
    physx::PxPhysics* mPhysics = nullptr;
    physx::PxDefaultCpuDispatcher* mDispatcher = nullptr;
    physx::PxScene* mScene = nullptr;
    physx::PxMaterial* mMaterial = nullptr;
    physx::PxPvd* mPvd = nullptr;
    physx::PxCudaContextManager* mCudaContextManager = nullptr; // <-- FULLY QUALIFIED
    physx::PxPBDParticleSystem* mParticleSystem = nullptr;
    physx::PxParticleAndDiffuseBuffer* mParticleBuffer = nullptr;
    physx::PxRigidDynamic* mMovingWall = nullptr;

    int mMaxDiffuseParticles = 0;
    bool mIsRunning = true;
    bool mStep = true;

    std::vector<Particle> m_Particles;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Physics\PhysxBase.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\PlatformVulkanSurface.h -----

#pragma once

#include "vulkan\vulkan_core.h"
#include <Engine/Platform/PlatformWindow.h>

class PlatformVulkanSurface {
public:
    virtual ~PlatformVulkanSurface() {}
    virtual VkSurfaceKHR createSurface(VkInstance instance, PlatformWindow* window) = 0;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\PlatformVulkanSurface.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\PlatformWindow.h -----

#pragma once

class PlatformWindow {
public:
    virtual ~PlatformWindow() {}
    virtual void* getNativeHandle() = 0;
    virtual bool shouldClose() const = 0;
    virtual void pollEvents() = 0;
    virtual void getFramebufferSize(int& width, int& height) const = 0;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\PlatformWindow.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Linux\PlatformWindow_Linux.h -----

#pragma once

#ifdef __linux__

#include <GLFW/glfw3.h>
#include <Engine/Platform/PlatformWindow.h>

class PlatformWindow_Linux : public PlatformWindow {
public:
    PlatformWindow_Linux(int width, int height, const char* title);
    ~PlatformWindow_Linux();

    void getFramebufferSize(int& width, int& height) const override {
        glfwGetFramebufferSize(m_window, &width, &height);
    }
    void* getNativeHandle() override;
    GLFWwindow* getGLFWwindow() const { return m_window; }

    bool shouldClose() const override;
    void pollEvents() override;

private:
    GLFWwindow* m_window;
};

#endif 

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Linux\PlatformWindow_Linux.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Linux\VulkanSurface_Linux.h -----

#pragma once
#ifdef __linux__

#include "../PlatformVulkanSurface.h"

class VulkanSurface_Linux : public PlatformVulkanSurface {
public:
    VkSurfaceKHR createSurface(VkInstance instance, PlatformWindow* window) override;
};

#endif 

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Linux\VulkanSurface_Linux.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Windows\PlatformWindow_Windows.h -----

#pragma once

#ifdef _WIN32


#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif

#include <GLFW/glfw3.h>
#include <Engine/Platform/PlatformWindow.h>

class PlatformWindow_Windows : public PlatformWindow {
public:
    PlatformWindow_Windows(int width, int height, const char* title);
    ~PlatformWindow_Windows();
    void getFramebufferSize(int& width, int& height) const override {
        glfwGetFramebufferSize(m_window, &width, &height);
    }
    void* getNativeHandle() override;

    GLFWwindow* getGLFWwindow() const { return m_window; }

    bool shouldClose() const override;
    void pollEvents() override;

private:
    GLFWwindow* m_window;
};

#endif 

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Windows\PlatformWindow_Windows.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Windows\VulkanSurface_Windows.h -----

#pragma once
#ifdef _WIN32

#include "../PlatformVulkanSurface.h"
class VulkanSurface_Windows : public PlatformVulkanSurface {
public:
    VkSurfaceKHR createSurface(VkInstance instance, PlatformWindow* window) override;
};
#endif

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Platform\Windows\VulkanSurface_Windows.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameSceneManager.h -----

#pragma once
#include <vector>
#include <memory>
#include "Gameobjects/GameObject.h"

class GameSceneManager {
public:
    static GameSceneManager& getInstance() {
        static GameSceneManager instance;
        return instance;
    }
    GameObject* addGameObject() {
        auto obj = std::make_unique<GameObject>();
        GameObject* rawPtr = obj.get();
        m_gameObjects.push_back(std::move(obj));
        return rawPtr;
    }
    void initialize() {
        for (auto& obj : m_gameObjects)
            obj->initialize();
    }

    void update() {
        for (auto& obj : m_gameObjects)
            obj->update();
    }

    void render() {
        for (auto& obj : m_gameObjects)
            obj->render();
    }

private:
    GameSceneManager() = default;
    ~GameSceneManager() = default;
    GameSceneManager(const GameSceneManager&) = delete;
    GameSceneManager& operator=(const GameSceneManager&) = delete;

    std::vector<std::unique_ptr<GameObject>> m_gameObjects;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameSceneManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\MeshScene.h -----

#pragma once

#define GLM_ENABLE_EXPERIMENTAL

#include <vulkan\vulkan_core.h>
#include <glm/glm.hpp>
#include <Engine/Graphics/Mesh.h>
#include <Engine/Scene/GameObjects/BaseObject.h>
#include <Engine/Scene/Scene.h>
#include <glm\gtx\quaternion.hpp>

static inline void basisFromNormal(const glm::vec3& nIn,
    glm::vec3& t, glm::vec3& b, glm::vec3& n)
{
    n = glm::normalize(nIn);
    // Choose an up reference that isn't parallel to n
    glm::vec3 up = (std::abs(n.y) > 0.999f) ? glm::vec3(0, 0, 1) : glm::vec3(0, 1, 0);
    t = glm::normalize(glm::cross(up, n)); // tangent (? width axis)
    b = glm::cross(n, t);                  // bitangent (? height axis)
}

enum class ObjType {
    plane,
    model
};


class MeshScene : public Scene{
public:

    unsigned int addModel(const std::vector<Vertex>& Vertexes, const std::vector<uint16_t>& indices, glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles, const std::shared_ptr<Material> mat = {})
    {
        BaseObject* object = new BaseObject{ Vertexes, indices ,mat };

        object->setPosition(position, scale, rotationAngles);
        m_BaseObjects.push_back(object);

        return m_BaseObjects.size() - 1;
    }

    BaseObject* getBaseObject(unsigned int modelId)
    {
        if (modelId < m_BaseObjects.size())
        {
            return m_BaseObjects[modelId];
        }
        return nullptr;
    }

    unsigned int addRectangle(const glm::vec3& normal,
        const glm::vec3& color,
        float width, float height,
        glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles,
        const std::shared_ptr<Material> mat = {})
    {
        float halfW = width * 0.5f;
        float halfH = height * 0.5f;

        // Build a stable local frame from the normal
        glm::vec3 T, B, N;
        basisFromNormal(normal, T, B, N);

        // Positions in that frame: X?T (width), Y?B (height), Z along N
        glm::vec3 p0 = (-halfW) * T + (-halfH) * B; // bottom-left
        glm::vec3 p1 = (+halfW) * T + (-halfH) * B; // bottom-right
        glm::vec3 p2 = (+halfW) * T + (+halfH) * B; // top-right
        glm::vec3 p3 = (-halfW) * T + (+halfH) * B; // top-left

        glm::vec2 uv0(0.0f, 0.0f);
        glm::vec2 uv1(1.0f, 0.0f);
        glm::vec2 uv2(1.0f, 1.0f);
        glm::vec2 uv3(0.0f, 1.0f);

        std::vector<Vertex> vertices;
        std::vector<uint16_t> indices;

        vertices.push_back({ p0, N, color, uv0 });
        vertices.push_back({ p1, N, color, uv1 });
        vertices.push_back({ p2, N, color, uv2 });
        vertices.push_back({ p3, N, color, uv3 });

        uint16_t base = 0;
        indices.push_back(base + 0);
        indices.push_back(base + 1);
        indices.push_back(base + 2);
        indices.push_back(base + 0);
        indices.push_back(base + 2);
        indices.push_back(base + 3);

        BaseObject* object = new BaseObject{ vertices, indices, mat };
        object->setPosition(position, scale, rotationAngles); // world transform
        m_BaseObjects.push_back(object);
        return static_cast<unsigned int>(m_BaseObjects.size() - 1);
    }

    void initObject(VkPhysicalDevice& physicalDevice, VkDevice& device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue) {
        for (auto& object : m_BaseObjects) {
            object->init(physicalDevice, device, commandPool, graphicsQueue);
        }
    }

    void drawScene(VkPipelineLayout& pipelineLayout, VkCommandBuffer& buffer) {
        for (auto& object : m_BaseObjects) {
            object->draw(pipelineLayout, buffer);
        }
    }

    void updateLocationObject(unsigned int pos, glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles) {
        if (pos < m_BaseObjects.size()) {
            m_BaseObjects[pos]->setPosition(position, scale, rotationAngles);
        }
    }

    glm::vec3 getLocation(unsigned int pos) {
        if (pos < m_BaseObjects.size()) {
            return m_BaseObjects[pos]->getPosition();
        }
    }

    void deleteScene(VkDevice device) {
        for (auto& object : m_BaseObjects) {
            object->destroy(device);
        }
    }

private:
    std::vector<BaseObject*> m_BaseObjects{};
};


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\MeshScene.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\ParticleScene.h -----

#pragma once

#include <vulkan\vulkan_core.h>
#include <glm/glm.hpp>
#include <Engine/Graphics/Mesh.h>
#include <Engine/Scene/GameObjects/BaseObject.h>
#include <Engine/Scene/Scene.h>
#include <Engine/Graphics/ParticleGroup.h>

class ParticleScene : public Scene {
public:

    void addParticleGroup(physx::PxVec4* particleBuffer, int ParticleCount , std::vector<Particle> particles, glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles)
    {
        ParticleGroup* object = new ParticleGroup{ particleBuffer , ParticleCount , particles};
        object->setPosition(position, scale, rotationAngles);

        m_ParticleGroups.push_back(object);
    }

    void addParticleGroup(std::vector<Particle> particles)
    {
        ParticleGroup* object = new ParticleGroup{ nullptr , 0 , particles };

        m_ParticleGroups.push_back(object);
    }

    void drawScene(VkPipelineLayout& pipelineLayout, VkCommandBuffer& buffer) {
        for (auto& object : m_ParticleGroups) {
            object->draw(pipelineLayout, buffer);
        }
    }

    void deleteScene(VkDevice device) {
        for (auto& object : m_ParticleGroups) {
            object->destroyParticleGroup(device);
        }
    }

    ParticleGroup* getLastParticleGroup()
    {
        if (m_ParticleGroups.size())
        {
            return m_ParticleGroups[m_ParticleGroups.size() - 1];
        }
        return nullptr;
       
    }

private:
    std::vector<ParticleGroup*> m_ParticleGroups{};
};


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\ParticleScene.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\Scene.h -----

#pragma once
#include <Engine/Graphics/ShaderBase.h>
class Scene {
public:

    virtual void drawScene(VkPipelineLayout& pipelineLayout, VkCommandBuffer& buffer) = 0;
    virtual  void deleteScene(VkDevice device) = 0;
    
};


----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\Scene.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\SceneModelManager.h -----

#pragma once

#include <vector>
#include <variant>
#include "MeshScene.h"
#include "ParticleScene.h"

enum class SceneModelType {
    Mesh,
    Particle
};

struct SceneObject {
    SceneModelType type;
    std::variant<BaseObject*, ParticleGroup*> object;
};

class SceneModelManager {
public:
    static SceneModelManager& getInstance() {
        static SceneModelManager instance;
        return instance;
    }

    SceneModelManager(const SceneModelManager&) = delete;
    SceneModelManager& operator=(const SceneModelManager&) = delete;

    void initScenes(VkPhysicalDevice& physicalDevice, VkDevice& device,
        const VkCommandPool& commandPool, const VkQueue& graphicsQueue) {
        m_meshScene->initObject(physicalDevice, device, commandPool, graphicsQueue);
       
    }

    BaseObject* addMeshModel(const std::vector<Vertex>& vertices,
        const std::vector<uint16_t>& indices,
        glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles, const std::shared_ptr<Material> mat = {})
    {
        unsigned int index = m_meshScene->addModel(vertices, indices, position, scale, rotationAngles, mat);
        BaseObject* obj = m_meshScene->getBaseObject(index); 
        m_sceneObjects.push_back({ SceneModelType::Mesh, obj });
        return obj;
    }

    BaseObject* addMeshRectangle(const glm::vec3& normal,
        const glm::vec3& color,
        float width, float height,
        glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles, const std::shared_ptr<Material> mat = {})
    {
        unsigned int index = m_meshScene->addRectangle(normal, color, width, height, position, scale, rotationAngles, mat);
        BaseObject* obj = m_meshScene->getBaseObject(index); 
        m_sceneObjects.push_back({ SceneModelType::Mesh, obj });
        return obj;
    }

    ParticleGroup* addParticleGroup(physx::PxVec4* particleBuffer, int ParticleCount, std::vector<Particle> particles, glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles)
    {
        m_particleScene->addParticleGroup(particleBuffer,ParticleCount,particles,position,scale,rotationAngles);
        ParticleGroup* obj = m_particleScene->getLastParticleGroup(); 
        m_sceneObjects.push_back({ SceneModelType::Particle, obj });
        return obj;
    }

    const std::vector<SceneObject>& getSceneObjects() const {
        return m_sceneObjects;
    }

    void updateObjectTransform(size_t index, glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles) {
        if (index >= m_sceneObjects.size()) {
            return;
        }
        const SceneObject& sceneObj = m_sceneObjects[index];
        if (sceneObj.type == SceneModelType::Mesh) {
            BaseObject* obj = std::get<BaseObject*>(sceneObj.object);
            if (obj)
                obj->setPosition(position, scale, rotationAngles);
        }
        else if (sceneObj.type == SceneModelType::Particle) {
            ParticleGroup* obj = std::get<ParticleGroup*>(sceneObj.object);
            if (obj)
                obj->setPosition(position, scale, rotationAngles);
        }
    }

    void destroy(VkDevice device) {
        m_meshScene->deleteScene(device);
        m_particleScene->deleteScene(device);
    }

    MeshScene* getMeshScene() { return m_meshScene; }
    ParticleScene* getParticleScene() { return m_particleScene; }

private:
    SceneModelManager() {
        m_meshScene = new MeshScene();
        m_particleScene = new ParticleScene();
    }

    ~SceneModelManager() {
        delete m_meshScene;
        delete m_particleScene;
    }

    MeshScene* m_meshScene;
    ParticleScene* m_particleScene;
    std::vector<SceneObject> m_sceneObjects;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\SceneModelManager.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\BaseObject.h -----

#pragma once

#include <glm/glm.hpp>
#include <Engine/Graphics/Mesh.h>
#include <memory>

class BaseObject {
public:
    BaseObject(const std::vector<Vertex>& Vertexes, const std::vector<uint16_t>& indices, const std::shared_ptr<Material> mat = {}) {
        mesh = std::make_unique<Mesh>(Vertexes, indices, mat);
    }
   
    void draw(VkPipelineLayout& pipelineLayout, VkCommandBuffer& buffer) {
        mesh->draw(pipelineLayout, buffer);
    }

    void setPosition(glm::vec3 position, glm::vec3 scale, glm::vec3 rotationAngles) {
        mesh->setPosition(position, scale, rotationAngles);
    }

    glm::vec3 getPosition() {
        return mesh->getPostion();
    }

    void init(VkPhysicalDevice& physicalDevice, VkDevice& device, const VkCommandPool& commandPool, const VkQueue& graphicsQueue) {
        mesh->initialize(physicalDevice, device, commandPool, graphicsQueue);
    }

    void destroy(VkDevice device) {
        mesh->destroyMesh(device);
    }
protected:
    std::unique_ptr<Mesh> mesh;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\BaseObject.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\Component.h -----

#pragma once

class GameObject;

class Component {
public:
    virtual ~Component() = default;

    void setParent(GameObject* parent) { m_parent = parent; }

    GameObject* getParent() const { return m_parent; }

    virtual void initialize() {}
    virtual void update() {}
    virtual void render() {}

protected:
    GameObject* m_parent = nullptr;
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\Component.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\GameObject.h -----

#pragma once

#include <vector>
#include <memory>
#include <type_traits>
#include "Component.h"
#include "TransformComponent.h"
#include "ModelMeshComponent.h"
#include "PrimitiveMeshComponent.h"

class GameObject {
public:
    GameObject() {
        m_transform = addComponent<TransformComponent>();
    }

    ~GameObject() = default;

    template<typename T, typename... Args>
    T* addComponent(Args&&... args) {
        static_assert(std::is_base_of<Component, T>::value, "T must derive from Component");
        auto component = std::make_unique<T>(std::forward<Args>(args)...);
        T* rawPtr = component.get();
        rawPtr->setParent(this);
        m_components.push_back(std::move(component));
        return rawPtr;
    }

    template<typename T>
    bool hasComponent() const {
        for (const auto& comp : m_components) {
            if (dynamic_cast<T*>(comp.get()))
                return true;
        }
        return false;
    }

    void initialize() {
        for (auto& comp : m_components)
            comp->initialize();
    }

    void update() {
        for (auto& comp : m_components)
            comp->update();
    }

    void render() {
        for (auto& comp : m_components)
            comp->render();
    }

    TransformComponent* getTransform() const { return m_transform; }

private:
    std::vector<std::unique_ptr<Component>> m_components;
    TransformComponent* m_transform; 
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\GameObject.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\ModelMeshComponent.h -----

#pragma once

#include "Component.h"
#include <vector>
#include <string>
#include <iostream>

class ModelMeshComponent : public Component {
public:
    ModelMeshComponent(GameObject* parent, const std::string& modelFile) {
        setParent(parent);
        addModelToScene(modelFile);
    }

    void initialize() override {
        std::cout << "ModelMeshComponent initialized." << std::endl;
    }
    void update() override {
        std::cout << "ModelMeshComponent updated." << std::endl;
    }
    void render() override {
        std::cout << "ModelMeshComponent rendered." << std::endl;
    }

private:
    void addModelToScene(const std::string& modelFile); 
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\ModelMeshComponent.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\PrimitiveMeshComponent.h -----

#pragma once

#include "Component.h"
#include "../SceneModelManager.h"
#include <glm/glm.hpp>
#include <iostream>

enum class PrimitiveType {
    Plane,
    Cube
};

class PrimitiveMeshComponent : public Component {
public:
    PrimitiveMeshComponent(GameObject* parent, PrimitiveType type, float width = 1.f, float height = 1.f, float depth = 1.f, const std::shared_ptr<Material> mat = {}) {
        setParent(parent);
        addPrimitiveToScene(type, width, height, depth, mat);
    }

    void initialize() override {
        std::cout << "PrimitiveMeshComponent initialized." << std::endl;
    }
    void update() override {
        std::cout << "PrimitiveMeshComponent updated." << std::endl;
    }
    void render() override {
        std::cout << "PrimitiveMeshComponent rendered." << std::endl;
    }

private:
    // Updated to accept dimensions.
    void addPrimitiveToScene(PrimitiveType type, float width, float height, float depth, const std::shared_ptr<Material> mat = {});
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\PrimitiveMeshComponent.h -----


----- Start of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\TransformComponent.h -----

#pragma once

#include "Component.h"
#include <glm/glm.hpp>
#include <iostream>

class TransformComponent : public Component {
public:
    TransformComponent()
        : position(0.0f), scale(1.0f), rotation(0.0f) {
    }

    glm::vec3 position;
    glm::vec3 scale;
    glm::vec3 rotation;

    void initialize() override {
        std::cout << "TransformComponent initialized." << std::endl;
    }

    void update() override {
        std::cout << "TransformComponent updated." << std::endl;
    }

    void render() override {
        std::cout << "TransformComponent rendered." << std::endl;
    }
};

----- End of file: C:\Users\briek\Documents\GitHub\VulkanRenderer\project\Engine\Scene\GameObjects\TransformComponent.h -----

